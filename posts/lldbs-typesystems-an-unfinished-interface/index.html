<!doctype html><html dir=auto lang=en><head><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="index, follow" name=robots><title>LLDB's TypeSystems: An Unfinished Interface</title><meta name=keywords><meta name=description><meta content=Walnut356 name=author><link href=https://walnut356.github.io/posts/lldbs-typesystems-an-unfinished-interface/ rel=canonical><link href=/styles.css rel=stylesheet><link href=/override.css rel=stylesheet><link href=/syntax-theme.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel=stylesheet><link crossorigin href=/CascadiaCode-Regular.woff2 rel=font><link href=/favicon.png rel=icon type=image/x-icon><link href=https://walnut356.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src="https://www.googletagmanager.com/gtag/js?id=G-PKLX5VEB4H" async></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PKLX5VEB4H');</script><body class=dark id=top><script>if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }</script><header class=header><nav class=nav><div class=logo><a title="Cracking The Shell (Alt + H)" accesskey=h href=https://walnut356.github.io> Cracking The Shell </a><div class=logo-switches><button title="(Alt + T)" accesskey=t id=theme-toggle><svg viewbox="0 0 24 24" fill=none height=18 id=moon stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> <svg viewbox="0 0 24 24" fill=none height=18 id=sun stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></button><ul class=lang-switch><li></ul></div></div><ul id=menu><li><a href=https://walnut356.github.io/archive title=Archive> <span>Archive</span> </a><li><a href=https://walnut356.github.io/search title=Search> <span>Search</span> </a><li><a href=https://walnut356.github.io/tags title=Tags> <span>Tags</span> </a></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://walnut356.github.io>Home</a> »  <a href=https://walnut356.github.io/posts/>Posts</a> »  <a href=https://walnut356.github.io/posts/lldbs-typesystems-an-unfinished-interface/>LLDB's TypeSystems: An Unfinished Interface</a></div><h1 class=post-title>LLDB's TypeSystems: An Unfinished Interface</h1><div class=post-meta><span title="2025-03-28 00:00:00 +0000">2025-03-28</span> · 25 min · 4884 words</div></header><div class=toc><details><summary title="(Alt + C)" accesskey=c><span class=details>Table of Contents</span></summary> <div class=inner><ul><li><a aria-label="What does a TypeSystem do?" href=#what-does-a-typesystem-do>What does a TypeSystem do?</a><li><a aria-label="DWARF AST Parsing, Types, and Decls" href=#dwarf-ast-parsing-types-and-decls>DWARF AST Parsing, Types, and Decls</a> <ul><li><a aria-label="A Quick Jaunt into Madness" href=#a-quick-jaunt-into-madness>A Quick Jaunt into Madness</a> <ul><li><a aria-label="QualType diversion" href=#qualtype-diversion>QualType diversion</a><li><a aria-label="Back to DeclContexts" href=#back-to-declcontexts>Back to DeclContexts</a><li><a aria-label="RecordType diversion" href=#recordtype-diversion>RecordType diversion</a><li><a aria-label="TagType diversion" href=#tagtype-diversion>TagType diversion</a><li><a aria-label="TagDecl divsersion" href=#tagdecl-divsersion>TagDecl divsersion</a><li><a aria-label="Back to RecordType" href=#back-to-recordtype>Back to RecordType</a><li><a aria-label="Back to TagType" href=#back-to-tagtype>Back to TagType</a></ul><li><a aria-label="Interesting TagDecl diversion" href=#interesting-tagdecl-diversion>Interesting TagDecl diversion</a> <ul><li><a aria-label="Redecl diversion" href=#redecl-diversion>Redecl diversion</a><li><a aria-label="Back to TagDecl" href=#back-to-tagdecl>Back to TagDecl</a></ul></ul><li><a aria-label="What does TypeSystem do? (for real this time)" href=#what-does-typesystem-do-for-real-this-time>What does TypeSystem do? (for real this time)</a><li><a aria-label="Mixed Messages" href=#mixed-messages>Mixed Messages</a><li><a aria-label="Will it make Rust debugging better?" href=#will-it-make-rust-debugging-better>Will it make Rust debugging better?</a></ul></div></details></div><div class=post-content><p>Well, it's "done". <code>TypeSystemRust</code> has a <a href=https://github.com/Walnut356/llvm-project/tree/lldbrust/19.x rel=noopener target=_blank>(semi) working prototype for LLDB 19.x</a>. It doesn't support expressions or MSVC targets (i.e. PDB debug info), and there are a whole host of catastrophic crashes, but it more or less proves what it needs to: Rust's debugging experience <em>can</em> be improved, and there are worthwhile benefits to a working <code>TypeSystem</code> that can't be emulated on other layers of the debugging stack.<p>If you want to test it out, you'll need to build my fork from source (sorry), but then <code>lldb.exe</code> can be used as-is, or you can point a debugger extension like lldb-dap or CodeLLDB to your newly built <code>lldb-dap.exe</code> or <code>liblldb.dll</code> respectively. If you're on Windows, make sure to compile for MSVC otherwise CodeLLDB won't be able to interface with <code>liblldb</code> properly.</p><span id=continue-reading></span><p>This is a loose followup to my <a href=https://walnut356.github.io/posts/so-you-want-better-debug-info/ rel=noopener target=_blank>previous post</a> about improving Rust's debugging experience. It's not 100% necessary reading, but explains some details about the debugging stack, the challenges of getting debug output to work properly with different debuggers, and why I'd spend a such a big chunk of time on this. For reference, this plugin took me a little over a month to write. I didn't track hours because I'm a dummy, but I'd probably put it in the ballpark of 80-100. I'd like to think that's due to the mitigating factors that I'll get into below, rather than me just being slow. It also would have taken <em>significantly</em> longer had I not had Vadimcn's LLDB 16.x <code>TypeSystemRust</code> to use as a reference (if you're reading this, your warnings were 100% correct lol).<p>To quickly list some benefits of a dedicated <code>TypeSystem</code>:<ul><li><em>Drastically</em> improved performance, especially when displaying container types (e.g. <code>Vec</code>, <code>Hashmap</code>, etc.) due to <code>SyntheticProviders</code> being compiled C++ rather than python scripts. There's also ways to cut down on a decent amount of the regex usage.<li>Debug nodes can be interpreted in arbitrary ways, meaning we can convey significantly more information to the debugger at compile-time. This means we have a ton more options to prettify the output and extract useful information (e.g. <code>mut</code> vs non-<code>mut</code> pointers/refs/variables, better/easier <code>dyn T</code> inspection, better source-mapping of closures)<li>Rust expressions in the lldb repl (e.g. <code>x as *const u8</code> rather than <code>(u8*)x</code>, <code>x.y</code> instead of <code>x->y</code>) and could allow for some very cool tricks like retrieving <code>Hashmap</code> values through the familiar <code>map[key]</code> syntax.<li>Debugger visualizer scripts should end up easier for library authors to write since we can ensure consistent information regardless of the debug info available - currently PDB-based debug info requires a few helping hands from the script to do its job properly. By stuffing those hacks in the <code>TypeSystem</code>, we wouldn't need to have a string-manipulation-<code>get_template_args</code> function in every single python script. We could also improve the <code>SBType</code> and <code>SBValue</code> interfaces themselves to allow them to access more of the DWARF modifiers and possibly upstream those improvements to LLDB itself.</ul><p>If the title of the post wasn't clear, I have some... <em>opinions</em> regarding my experience writing the plugin. I do intend to help contribute to some fixes, but I'm one person with limited time and motivation. I want to record my thoughts here though, because I think they're the most valuable at this exact moment: I'm now <em>somewhat</em> familiar with LLDB internals, but 2 months ago I was starting from 0. It's easy for people creating &LTa thing> to lose perspective and not understand the difficulties faced by those who don't already have an intimate understanding of the system itself or its context (supporting systems, jargon, domain knowledge). That perspective is <em>vitally</em> important for a public API that is meant to be used by people who aren't LLDB devs.<p>On one hand, it's a very powerful interface and it surprised me with how much "just works" by implementing relatively few functions. On the other, the architecture is unbelievably convoluted and the documentation is, with no exaggeration, completely non-existent. I think it is <em>incredibly</em> close to being in a mainstream-useable state, but the current issues make it difficult to recommend to the third party languages it's trying to appeal to.<p>As of writing, I know of exactly 3 implementations of the <code>TypeSystem</code> interface aside from mine: <code>TypeSystemClang</code>, which is shipped with LLDB and supports C/C++ (with partial support for Pascal, Rust, and D); <code>TypeSystemSwift</code> which is maintained by literally Apple in <a href=https://walnut356.github.io/posts/lldbs-typesystems-an-unfinished-interface/(https://github.com/swiftlang/llvm-project/tree/next/lldb/source/Plugins/TypeSystem/Swift)>their fork of LLVM</a>; and <code>TypeSystemRust</code>, <a href="https://archive.softwareheritage.org/browse/origin/directory/?branch=refs/heads/codelldb/16.x&origin_url=https://github.com/vadimcn/llvm-project&path=lldb/source/Plugins/TypeSystem/Rust&timestamp=2023-09-11T04:55:10Z" rel=noopener target=_blank>formerly upkept by Vadimcn</a> for the popular CodeLLDB VSCode extension.<p>After writing my own <code>TypeSystemRust</code>, the low number of implementers does not surprise me.<h1 id=what-does-a-typesystem-do>What does a <code>TypeSystem</code> do?<a aria-hidden=true class=anchor hidden href=#what-does-a-typesystem-do>#</a></h1><p>I mentioned this in my previous post, but the <a href=https://lldb.llvm.org/resources/addinglanguagesupport.html#add-a-typesystem-for-the-language rel=noopener target=_blank>official docs</a> don't really say. Alarmingly, the comments in the source code don't explain anything either:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> Interface for representing a type system.
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span>
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> Implemented by language plugins to define the type system for a given
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> language.
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span>
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> This interface extensively used opaque pointers to prevent that generic
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> LLDB code has dependencies on language plugins. The type and semantics of
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> these opaque pointers are defined by the TypeSystem implementation inside
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> the respective language plugin. Opaque pointers from one TypeSystem
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> instance should never be passed to a different TypeSystem instance (even
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> when the language plugin for both TypeSystem instances is the same).
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span>
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> Most of the functions in this class should not be called directly but only
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> called by their respective counterparts in CompilerType, CompilerDecl and
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> CompilerDeclContext.
</span></span></code></pre><p>The first two lines basically say "A TypeSystem is a TypeSystem". I've said it before, but ideal documentation should, bare minimum, answer the following 3 questions:<ul><li>What does this do?<li>Why would I want it to (use-case, comparison to similar methods, etc.)?<li>How does it do it (internal implementation, performance characteristics, failure states)?</ul><p>The third question is answered, but the first two aren't. Perusing the methods is equally unhelpful; the majority have no comments at all and their names require a bunch of contextual knowledge to understand. Some appear similar in name to parts of the Python interface, but that's still not an answer. <code>TypeSystemClang</code>'s comments (of which there are few) and implementation also don't make things any clearer, but for different reasons that I'll get into later.<p>A quick once-over of the <code>Language</code> and <code>LanguageRuntime</code> interfaces suggests that those plugins are used similarly to the Python interface - run-time value inspection and formatting. It's not clear how <code>TypeSystem</code> fits into that. The only other hint given by the official docs is that if the debug info is coming from DWARF, the <code>TypeSystem</code> should subclass <code>DWARFASTParser</code>.<h1 id=dwarf-ast-parsing-types-and-decls>DWARF AST Parsing, Types, and Decls<a aria-hidden=true class=anchor hidden href=#dwarf-ast-parsing-types-and-decls>#</a></h1><p><code>DWARFASTParser</code> is an interface that takes raw dwarf debug info entries (DIE's or, informally, nodes) from a <code>SymbolFileDWARF</code> and turns them into an in-memory representation of the type (which I'll call <code>LangType</code>). A <code>void*</code> to the <code>LangType</code> is then wrapped in a <code>CompilerType</code>, which associates it with the appropriate <code>TypeSystem</code>. The <code>CompilerType</code> is passed back to the <code>SymbolFileDWARF</code>, which associates it with its DIE for later retrieval, wraps it in an <code>lldb::Type</code> - an object that also contains contextual information about the type - and passes a shared pointer to that back to the <code>DWARFASTParser</code>. The <code>DWARFASTParser</code> populates the contextual information if possible, and then passes the <code>lldb::Type</code> back to whoever called <code>ParseTypeFromDWARF</code> in the first place.<p>Uh.... huh.<p>In Rust terms, the class layout it looks vaguely like this:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-storage z-type z-trait z-rust">trait</span> <span class="z-entity z-name z-trait z-rust">TypeSystem</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span><span class="z-keyword z-operator z-range z-rust">...</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">LangType</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span></span></span><span class="z-keyword z-operator z-range z-rust">...</span>}
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">CompilerType</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">lang_type</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-modifier z-rust"><span class="z-keyword z-operator z-symbol z-rust">*</span>mut</span> <span class="z-identifier z-rust">c_void</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">type_system</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Arc</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-trait z-rust">dyn</span> <span class="z-identifier z-rust">TypeSystem</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span> </span><span class="z-meta z-impl z-rust"><span class="z-entity z-name z-impl z-rust">CompilerType</span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> implements a similar interface to TypeSystem
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> and delegates everything
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get_byte_size</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-keyword z-other z-self z-rust">self</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-storage z-type z-primitive z-rust">usize</span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">type_system</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get_byte_size</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">lang_type</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-operator z-range z-rust">...</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> implements a similar interface to CompilerType
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> but also has other data and utilities
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Type</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">compiler_type</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-identifier z-rust">CompilerType</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    </span></span><span class="z-keyword z-operator z-range z-rust">...</span>
</span><span class="z-source z-rust">}
</span></code></pre><p>The purpose of this "telescopic" class layout is, ostensibly, to allow arbitrary <code>LangType</code> structs and <code>TypeSystem</code> implementations.<p>In context, that implies that the purpose of the <code>TypeSystem</code> is to cast the <code>void*</code> back to a <code>LangType*</code> and interpret the internals of that <code>LangType</code> for queries like <code>GetByteSize()</code> and <code>GetFieldAtIndex()</code>, right?<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span> </span><span class="z-meta z-impl z-rust"><span class="z-identifier z-rust">TypeSystem</span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-entity z-name z-impl z-rust">TypeSystemLang</span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get_byte_size</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">t</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-modifier z-rust"><span class="z-keyword z-operator z-symbol z-rust">*</span>mut</span> <span class="z-identifier z-rust">c_void</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-storage z-type z-primitive z-rust">usize</span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">lang_type</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">t</span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-modifier z-rust"><span class="z-keyword z-operator z-symbol z-rust">*</span>mut</span> <span class="z-storage z-type z-source z-rust">LangType</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> operate on the internals of LangType
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> that CompilerType doesn't know about
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-operator z-range z-rust">...</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>Well... maybe.<p>I'm going to come back to that, but first I want to cover the architectural issues. The whole <code>Type</code>, <code>CompilerType</code>, <code>LangType</code> thing isn't horrible, but mixed with the litany of other classes that work this way it gets very tangled very quickly.<p>There's this feeling of inconsistency when operating on data, because it's not always clear when you should be storing/using any of the 3 layers of <code>Type</code> objects (which doesn't even count things like <code>TypeImpl</code> and <code>SBType</code>). To make matters worse, the names of classes and methods aren't descriptive enough on their own to convey intent properly. You can dig into the implementation, but that's a huge undertaking because the class relationships make it hard to find where the logic-code even is.<p><code>DWARFDIE</code> is a big offender. 90% of your time implementing the <code>DWARFASTParser</code> is monkeying with <code>DWARFDIE</code> objects and their subsidiaries (<code>DWARFAttributes</code>, <code>DWARFFormValue</code>, etc.). Does the DIE in <code>DWARFDIE</code> stand for Debug Info Entry? Probably, but if so, why is there <em>also</em> a <code>DWARFDebugInfoEntry</code> class and in what way is it different? Neither are documented in any way, so you'll have to figure that out for yourself. I had a good laugh the first time I saw <code>GetDIE()</code>, a <code>DWARFDIE</code> method which returns a <code>DWARFDebugInfoEntry</code>. That method doesn't have a doc comment either so it just looks like absolute nonsense.<p>Let's say you have a <code>DWARFFormValue</code> - a wrapper around the data in a DWARF attribute - and you call <code>Reference()</code> on it. One overload returns a <code>DWARFDIE</code>, other other takes a <code>uint64_t</code> and returns a <code>uint64_t</code>. What does that function do? How can the overloads possibly accomplish the same thing with return-type differences like that? Some DWARF attributes like <code>DW_AT_type</code> store offsets into the DWARF file that point to other DWARF nodes. I assume the first overload "dereferences" that offset and returns the appropriate DIE. But not every attribute tag stores an offset. Can this function fail? How so? If it really does what I think it does, why isn't it called <code>Dereference</code>, or <code>GetReferencedDIE</code>? The latter is the name of a method on <code>DWARFDIE</code> (that, funnily enough, ends up calling <code>DWARFFormValue::Reference()</code>) and is a much better "self documenting" name than <code>Reference</code>.<p>Can I find this out by reading the source code? Kinda, but I end up having to jump down 7 other rabbit holes. Should I be able to hover over the type name and have most those questions answered in a few seconds by the doc comments? <strong>Yes</strong>.<p>Several dozen hours into writing the <code>TypeSystem</code>, I read in the LLVM contribution guidelines that <a href=https://llvm.org/docs/CodingStandards.html#class-overviews rel=noopener target=_blank>every class and function needs to be described</a>. It specifically states <strong>"The reader should be able to understand how to use interfaces without reading the code itself"</strong>. Would that I could describe the bitter, betrayed sound that escaped my throat in that moment. The handful of words that followed are left to your imagination.<p>I'm going to temporarily put on the green goblin mask to prove a point, so don't worry too much if you don't understand the finer details.<h3 id=a-quick-jaunt-into-madness>A Quick Jaunt into Madness<a aria-hidden=true class=anchor hidden href=#a-quick-jaunt-into-madness>#</a></h3><p>Near the end of the <code>DWARFASTParser</code> implementation, I had to write functions to create and retrieve <code>Decl</code> and <code>DeclContext</code> objects. In short, <code>Decl</code>s are declarations/definitions of structs, typedefs, functions, etc. <code>DeclContext</code>s are scopes (compile unit, struct, lexical block, etc.) and they store <code>Decl</code>s. Worth noting, both of these classes are defined within <code>libclang</code>, not <code>liblldb</code>. They also have the same <code>CompilerDecl</code> relationship to <code>Decl</code> as <code>CompilerType</code> has to <code>LangType</code>. None of that is clear at first glance and requires digging into a bunch of <em>other</em> stuff, but if I went into that we'd be here all day.<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> same for Decl
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">DeclContext</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span></span></span><span class="z-keyword z-operator z-range z-rust">...</span>}
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">CompilerDeclContext</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">decl_ctx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-modifier z-rust"><span class="z-keyword z-operator z-symbol z-rust">*</span>mut</span> <span class="z-identifier z-rust">c_void</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">type_system</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Arc</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-trait z-rust">dyn</span> <span class="z-identifier z-rust">TypeSystem</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>To figure out where <code>DeclContext</code>s come from and how they're associated with type in the first place, I started with the <code>TypeSystemClang</code> entry point <code>GetDeclContextForType</code>, which is passed a <code>CompilerType&</code>. <code>GetDeclContextForType</code> internally calls an overloaded version of the same function that takes a <code>QualType</code>. That <code>QualType</code> is acquired via <code>ClangUtil::GetQualType(compiler_type)</code> Now we have additional questions: what is <code>ClangUtil::GetQualType</code>, and what is a <code>QualType</code>?<h4 id=qualtype-diversion>QualType diversion<a aria-hidden=true class=anchor hidden href=#qualtype-diversion>#</a></h4><p>Internally, that calls <code>QualType::getFromOpaquePtr(compiler_type.GetOpaqueQualType())</code> which is pretty straight forward. Except 1. <code>getFromOpaquePtr</code> uses a different capitalization scheme from seemingly the entire rest of the LLVM codebase for some reason? and 2. <code>GetOpaqueQualType</code> just returns the <code>void*</code> to the <code>LangType</code>.<p>But wait, since the <code>CompilerType</code> function is specifically called "get opaque <strong>QualType</strong>", that means <code>QualType</code> - defined within the <code>clang</code> compiler itself - is the expected type underlying <code>CompilerType</code>'s <code>void*</code>, right? Does that mean I should be using <code>QualType</code> for <code>TypeSystemRust</code>? Surely not, otherwise why use a <code>void*</code> at all?<p>Anyway, <code>QualType</code> is a packed-pointer type, basically a <code>clang::Type*</code> with a bit of extra metadata. Looking at the methods of <code>QualType</code>, it looks like it's very much built for C/C++ types. <code>clang::Type</code> (different from <code>lldb::Type</code>) appears to be a bitfields describing a type.<p>Anyway, where were we again?<h4 id=back-to-declcontexts>Back to DeclContexts<a aria-hidden=true class=anchor hidden href=#back-to-declcontexts>#</a></h4><p>Right, <code>TypeSystemClang::GetDeclContextForType</code>, which takes a <code>QualType</code>. For a quick tracer bullet, we'll look only at how struct types are handled. That code path returns <code>llvm::cast&LTclang::RecordType>(qual_type)->getDecl()</code>. Alright, so what is a <code>RecordType</code>?<h4 id=recordtype-diversion>RecordType diversion<a aria-hidden=true class=anchor hidden href=#recordtype-diversion>#</a></h4><p><code>RecordType</code> is a child of <code>TagType</code> that seems to be used purely for classification purposes, like a sum-type enum in Rust. So what is <code>TagType</code>?<h4 id=tagtype-diversion>TagType diversion<a aria-hidden=true class=anchor hidden href=#tagtype-diversion>#</a></h4><p>A child of <code>clang::Type</code>, but with 1 extra member of type <code>TagDecl</code>. What is a <code>TagDecl</code>?<h4 id=tagdecl-divsersion>TagDecl divsersion<a aria-hidden=true class=anchor hidden href=#tagdecl-divsersion>#</a></h4><p>According to the doc comment, "Represents the declaration of a struct/union/class/enum." and it inherits from <code>DeclContext</code> among other things.<h4 id=back-to-recordtype>Back to RecordType<a aria-hidden=true class=anchor hidden href=#back-to-recordtype>#</a></h4><p>Where were we? Oh yeah, <code>RecordType::getDecl()</code>. That returns <code>(RecordDecl*)(TagType::getDecl())</code>. What does <code>TagType::getDecl()</code> do?<h4 id=back-to-tagtype>Back to TagType<a aria-hidden=true class=anchor hidden href=#back-to-tagtype>#</a></h4><p>Returns <code>getInterestingTagDecl(decl)</code>. Yes, it's really called that. So what does <code>getInterestingTagDecl</code> do?<h3 id=interesting-tagdecl-diversion>Interesting TagDecl diversion<a aria-hidden=true class=anchor hidden href=#interesting-tagdecl-diversion>#</a></h3><p>It iterates over "redecls" and returns the first one that passes <code>isCompleteDefinition() || isBeingDefined()</code>.<p>So what is a redecl?<h4 id=redecl-diversion>Redecl diversion<a aria-hidden=true class=anchor hidden href=#redecl-diversion>#</a></h4><p>clangd points me to an inherited function from <code>Redeclarable&LTTagDecl></code>, whose doc comment helpfully explains "Returns an iterator range for all the redeclarations of the same decl. It will iterate at least once (when this decl is the only one)". Neat I guess? So we can more or less pretend that it doesn't exist. But wait, how does <code>TagDecl</code> fit into this again? We saw it earlier, but now we need to know more.<h4 id=back-to-tagdecl>Back to TagDecl<a aria-hidden=true class=anchor hidden href=#back-to-tagdecl>#</a></h4><p><code>TagDecl</code> inherits <code>Decl</code> and <code>DeclContext</code>. The <code>DeclContext</code> bitfields are what are inspected via <code>isCompleteDefinition()</code> and <code>isBeingDefined()</code>.<p>That value is then <code>reinterpret_cast</code> into a <code>RecordDecl*</code>, which has a bit of extra struct-related data.<p>So all-in-all, we have something like this? I don't even know<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> this is all in clang, not lldb
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Type</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span> </span></span><span class="z-keyword z-operator z-range z-rust">...</span> }
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Decl</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span> </span></span><span class="z-keyword z-operator z-range z-rust">...</span> }
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">DeclContext</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span> </span></span><span class="z-keyword z-operator z-range z-rust">...</span> }
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">TagDecl</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">decl</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-identifier z-rust">Decl</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">decl_ctx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-identifier z-rust">DeclContext</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span> </span><span class="z-meta z-impl z-rust"><span class="z-identifier z-rust">Redeclarable</span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-entity z-name z-impl z-rust">TagDecl</span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-operator z-range z-rust">...</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">RecordDecl</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">decl</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-identifier z-rust">TagDecl</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    </span></span><span class="z-keyword z-operator z-range z-rust">...</span>
</span><span class="z-source z-rust">}
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">TagType</span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">t</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-identifier z-rust">Type</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">decl</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-modifier z-rust"><span class="z-keyword z-operator z-symbol z-rust">*</span>const</span> <span class="z-identifier z-rust">TagDecl</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> maybe an enum with RecordType being a variant
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> would be more appropriate?
</span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">RecordType</span></span></span><span class="z-meta z-struct z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-identifier z-rust">TagType</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></code></pre><p>All of that, only to learn that a <code>DeclContext</code> should already be associated with a type before <code>GetDeclContextForType</code> is called and that it's function is just a simple member retrieval. Great...<p>While we're here, I just want to once again draw your attention to how many diversions you <em>haven't</em> seen. I presented you with a definition of <code>DeclContext</code> at the start of this and hand-waved away how I figured that out. The <code>DeclContext</code> class, being in clang instead of lldb, has a doc comment. It begins with the following:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> DeclContext - This is used only as base class of specific decl types that
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> can act as declaration contexts. These decls are (only the top classes
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> that directly derive from DeclContext are mentioned, not their subclasses):
</span></span></code></pre><p>and then proceeds to list <em>thirteen</em> other classes. And you're telling me that's not all of them?<p>Good <em>god</em>.<p>So no, I wasn't exaggerating when I said we'd be here all day if I didn't gloss over things. The kicker? The minimum information necessary to store in a <code>DeclContext</code> is the scope's name and a list of child <code>Decl</code>s. Clang's <code>DeclContext</code> <em>declaration</em> (not definition) spans <strong>1329</strong> lines of C++ code. <code>DeclContextRust</code>'s - which is both declaration <em>and</em> definition - takes just 44.<p>Hopefully I've made my point. Was any part of that explanation confusing? Did your eyes glaze over? Does some of the complexity seem a bit unnecessary?<p>Everything is like this. It's maddening. I called it a possible skill issue before, but I don't think so now. It really is just 17 layers of indirection when 0 would do. I mentioned before that <code>TypeSystemClang</code> wasn't a useful resource to explain what a <code>TypeSystem</code> does and this is why. It's a gigantic time-sink to understand, and once you finally do, you realize it ties itself to the clang compiler in a way that other languages can't, with underlying representations that contain huge swaths information that the debugger API can't even take advantage of.<p>I'll say again, it was still this painful <em>after</em> several dozen hours of mucking around in adjacent parts of LLDB and clang.<p>I get that piggybacking on clang's classes saves time, but the utility and specificity required by the compiler vs the debugger are so different that I feel like it's just not worth it. <code>TypeSystemClang</code> doesn't exist <em>purely</em> as a reference for people to use when implementing their own <code>TypeSystem</code>, but does <em>have</em> to serve as one. Muddying that reference this much for a small-ish time save and dubious extra functionality feels like a mistake to me.<h1 id=what-does-typesystem-do-for-real-this-time>What does <code>TypeSystem</code> do? (for real this time)<a aria-hidden=true class=anchor hidden href=#what-does-typesystem-do-for-real-this-time>#</a></h1><p>Most <code>TypeSystem</code> functions take a <code>void*</code>, cast it to a <code>LangType*</code>, and then operate on the underlying data to answer queries like <code>GetByteSize</code>, <code>IsEnumerationType</code>, and <code>GetFieldAtIndex</code><p>In my case, the implementation of <code>TypeSystemRust::GetByteSize</code> (or any inspection function for that matter) <em>does not</em> require any data that doesn't already exist within the <code>RustType</code> struct I've defined. Which makes sense, because <code>RustType</code> is how you communicate the debug info to the rest of LLDB in the first place.<p>So what does the <code>TypeSystem</code> itself do?<p>Nothing.<p>Or, at least, nothing that can't be done by something else. My implementation has precisely 1 capability that isn't handled somewhere else - a map that associates <code>DWARFDIE</code>s with their respective <code>CompilerDecl</code>/<code>CompilerDeclContext</code>. And even that <em>should</em> be handled by the <code>SymbolFileDWARF</code>, which already has a map that associates <code>DWARFDIE</code>s with <code>CompilerType</code>s.<p>I'm sure I could technically think of a use for being able to store info that can be accessed for all the types collectively, but I struggle to see the point when the <code>ASTParser</code> and <code>SymbolFile</code> interfaces can already do that. I do not understand why a <code>LangType</code> can't just inspect itself via a <code>Type</code> interface, with both the <code>TypeSystem</code> and <code>CompilerType</code> classes thrown in the garbage. It seems like all we're doing with a <code>TypeSystem</code> is manually implementing a v-table. Maybe there's a good reason for this, I don't know. Without any explanation, it feels unnecessary.<h1 id=mixed-messages>Mixed Messages<a aria-hidden=true class=anchor hidden href=#mixed-messages>#</a></h1><p>I want to make it clear that, in the official docs, it is <em>offhandedly</em> mentioned that "If your type info is going to come from DWARF info, you will want to subclass DWARFASTParser."<p>About 80% of the time I've spent so far was researching and implementing the <code>DWARFASTParser</code> and the <code>RustType</code> objects. I spent a single day writing the <code>TypeSystem</code> itself, and the remaining few days were spent writing the <code>Language</code> plugin that does things like displaying <code>Vec</code> elements instead of its heap pointer. Another sizeable chunk of time still needs to go into writing an expression parser.<p>If your goal is to get a better output than <code>TypeSystemClang</code> and it can't be fixed with the public <code>SB</code> API, the improvement is going to come from interpreting the debug info differently via <code>ASTParser</code> - thus generating different <code>LangType</code> objects - or via the <code>Language</code> plugin, which can interact with the <code>LangType</code> internals. If your goal is non-C expressions for the repl, that comes from the <code>ExpressionParser</code>, not the <code>TypeSystem</code>.<p><code>TypeSystem</code> is the vast <em>minority</em> of the work and does not really accomplish anything in isolation. It's just a middleman. The docs definitely do not make it clear enough that that is the case. Realizing "oh, this is actually going to be 10x more work than I was lead to believe" is not fun.<p>I guess maybe you could write a <code>TypeSystem</code> that uses <code>QualType</code>, thus you don't have to write your own <code>DWARFASTParser</code> but like... the point of this is <em>third party language support</em>. As a reminder, <code>QualType</code> relies on <code>clang::Type</code>, the internal representation for types in a <em>C/C++ compiler</em>. It is incredibly C-oriented, rightfully so. But that makes it <em>very</em> unsuited to third party languages when they have non-C concepts, or disagree with C about what a term "means". In Rust a reference is a borrowing pointer. In C++, a reference is a magical "maybe a pointer, maybe not, but you interact with it like it's not, wOoOoO" that debuggers treat as such.<blockquote><p>From <a href=https://en.cppreference.com/w/cpp/language/reference rel=noopener target=_blank>cppreference</a>:<p>References are not objects; <strong>they do not necessarily occupy storage</strong>, although the compiler may allocate storage if it is necessary to implement the desired semantics (e.g. a non-static data member of reference type usually increases the size of the class by the amount necessary to store a memory address).<p>Because references are not objects, there are <strong>no arrays of references, no pointers to references, and no references to references</strong></blockquote><p>This causes dumb issues that conflict with Rust's semantics even if the debug info is 100% accurate from the Rust compiler.<p>It might be a different story if there was a <code>TypeSystemLLVM</code> and a default <code>DWARFASTParserLLVM</code> that more or less just exposed the raw DWARF data in a default "sane" way. Maybe by assuming the data was generated via LLVM's <code>DIBuilder</code> API, and that if you have the <code>DW_TAG_struct</code> node, it probably represents a struct. At that point, it's on the compiler devs to make sure they're generating sane debug info, which is easy because they already are. There wouldn't be anything to gain or lose by implementing your own DWARF parser - a huge time-save for implementers - and the <code>LLVMType</code> objects given out could then be interpreted uniquely by the <code>TypeSystem</code> and/or <code>Language</code> plugin. Maybe that was the goal at some point, but right now we're in this awkward interim where the pieces don't fit together quite right.<p>Oh yeah, I almost forgot. What if your debug info comes from PDB, as it does for Rust compiled to <code>*-msvc</code>? Well, you get to eat shit.<p><code>DWARFASTParser</code> is an interface and is not <code>TypeSystem</code>-aware, so it can be subclassed by your <code>TypeSystem</code>, or you can make a standalone <code>DWARFASTParserRust</code>. For some reason, <code>PDBASTParser</code> is <em>not</em> an interface. Not only does <code>PDBASTParser</code>'s constructor require a <code>TypeSystem</code> it <em>explicitly</em> requires a <code>TypeSystemClang</code>.<p><img alt="Image showing PDB AST Parser requiring TypeSystemClang in its constructor" src=https://walnut356.github.io/posts/lldbs-typesystems-an-unfinished-interface/image-1.png><p>The can-of-worms required to fix that is why my prototype doesn't have PDB support at the moment.<h1 id=will-it-make-rust-debugging-better>Will it make Rust debugging better?<a aria-hidden=true class=anchor hidden href=#will-it-make-rust-debugging-better>#</a></h1><p>We've now arrived back at the title of the post. The <code>TypeSystem</code>/language support interface feels 80% complete. It's <em>so</em> close to being a game changer for debugging, but it's not something I could reasonably ask people on the Rust team (let alone random OSS contributors) to learn about and help maintain.<p>Maybe the convoluted architecture wouldn't be so bad if there were proper explanations of what everything is, what it does, and why it exists. Maybe the lack of documentation wouldn't be so bad if the architecture was simple and straightforward. As it stands though, both combined makes it too difficult to onboard people.<p>To be clear, I don't actually think the total surface area of <code>ASTParser</code> + <code>TypeSystem</code> + <code>Language</code> + <code>ExpressionParser</code> is too much, it's just too difficult to figure out <em>how</em> to implement them. I can see, beneath the current issues, a version of this interface that's reasonable to implement by a single person in a few days for their toy language, with no loss in power or flexibility.<p>It also might not be quite as easy to distribute as it appeared on the tin. It's called a "plugin", and LLDB has the capability to load some plugins dynamically at runtime. But from what I can tell, <code>TypeSystem</code> requires a full standalone build of LLDB because it works through LLDB's private internals rather than the <code>SB</code> API. I could absolutely be wrong about this, I haven't experimented with it enough to have a confident answer. If I'm right though, it'd be pretty disappointing. Building and distributing custom LLDB is a much bigger ask than distributing a <code>TypeSystemRust.dll</code>.<p>So as it stands, Rust debugging probably won't improve beyond little tweaks or fixes in the short term. That may change if the situation with LLDB improves, or if the core Rust maintainers take a keen interest and push through the roadblocks, akin to Apple with <code>TypeSystemSwift</code>.<p>In any case, I'll keep plugging away at this prototype, and maybe make some contributions to LLDB itself. Maybe some day it'll be more than a prototype. All of the groundwork is there for a better debugging experience, it's just going to take some time and some elbow grease.<hr><p>Last but not least, I have a few specific nitpicks. I hate to have them hanging off the end like this, but this post was already such a nightmare to organize and pace, so it is what it is.<ul><li><p>There are no facilities that I could find to inspect a <code>TypeSystem</code> at run-time. I couldn't see which <code>TypeSystem</code>s were loaded, dump their states, nor determine which languages were associated with which <code>TypeSystem</code>.</p><li><p>If multiple <code>TypeSystem</code>s are valid for a single language, there's no way to pick which one to use aside from removing the language from the results of <code>TypeSystem::SupportsLanguage</code> and recompiling. That means if there ever <em>is</em> an official <code>TypeSystemRust</code> (or <code>TypeSystem</code> can be loaded as a plugin), there would have to be an upstream change to <code>TypeSystemClang</code> to remove the Rust language flag.</p><li><p>There's weird little problems with the public <code>SB</code> interfaces. Some DWARF tags (including ones that C/C++ uses, <a href=https://en.cppreference.com/w/cpp/keyword/mutable rel=noopener target=_blank>such as the <code>DW_AT_mutable</code></a> or the <code>restrict</code> modifier) may as well not exist because there's no way to actually look at them via the SBType interface. It's weird because <code>lldb::Type</code> even has functions to add/remove the restrict modifier from a type, but the user-facing <code>SBType</code> interface can't access it so what's the point?</p><li><p>The function that allows you override a type's name when printing it out (python: <code>get_type_name</code>, C++ <code>GetSyntheticTypeName</code>) is not publicly documented despite being a <em>massive</em> feature of the <code>SyntheticProvider</code>. It's not mentioned anywhere, despite the documentation <a href=https://lldb.llvm.org/use/variable.html#synthetic-children rel=noopener target=_blank>describing the "full" interface</a>.</p><li><p>Headers relying on headers that are generated at compile time (like SBLanguages.h) is a weird choice. I'm sure there's a reason for it, but it leads to a lot of little annoyances prior to the first full build if you aren't able to source those files from elsewhere. This is partially on me for building this on Windows because I hate myself, but I don't think the requirement of a special <code>lldb-dev</code> package on Linux is a great situation either.</p><li><p>LLDB is dependent on clang, which means you need to do an in-tree build of clang before you can do a standalone build of LLDB. Everything is there, I'm not sure why cmake can't make it work without having to sit through 30+ minutes of a full clang compile, but it's pretty annoying.</p><li><p>An option to build liblldb as a static lib would be awesome for those of us who want to make FFI wrappers. Last I checked there was a PR for it, but when I tried to build from that PR I ended up with a bunch of linker errors that I wasn't able to diagnose - but I'm also not experienced with that stuff, so it could be a simple fix or a Windows issue. If that's not an option, a C interface akin to LLVM-C would be a huge help instead.</p><li><p>the <a href=https://lldb.llvm.org/resources/formatterbytecode.html rel=noopener target=_blank>formatter byte code</a>, while cool, is borderline worthless for targets that don't end up populating template args (e.g. <code>TypeSystemClang</code> with PDB debug info). You most want synthetic providers for container types, but if you can't get the type of the element, you can't cast the container's pointer. Being able to look up an arbitrary type by name could help, or <code>TypeSystemClang</code> could just actually pull the template args from PDB info. I know PDB doesn't have them explicitly, but <code>TypeSystemClang</code> primarily handles C++ and Rust, both of which use the same <code>S&LTT></code> syntax for templates.</p><li><p>From what I can tell, the only way to apply a Synthetic to a type is via a regex, an exact name match, or a callback via a python script. There should definitely be a way to take a C++ callback of some kind. For example, there's nothing in a Rust type's name that distinguishes a <code>struct</code> from a sum-type <code>enum</code>. Checking via regex requires a raw <code>.*</code> wildcard (which the current Rust-distributed scripts currently do), and then delegating to a "default" and "enum" provider, which is exorbitantly wasteful. Using a python function isn't much better since, well, it's python.</p></ul><p>In the C++ code you can return an invalid synthetic provider, but it still flags the type as having a synthetic, which causes issues for downstream consumers. For example, CodeLLDB adds an extra dropdown menu for values with synthetic types. Populating those isn't cheap when you have a <code>Vec</code> with 2000 <code>u8</code>'s in it.<p>Conversely, it's trivial for the <code>Language</code> plugin to cast the opaque type pointer to a <code>RustType</code> and call <code>IsSumType()</code>. It would be awesome if I could attach synthetics via that function. There is a <a href=https://github.com/Walnut356/llvm-project/blob/72c08d25f69266e001851b578801c229d1aba260/lldb/source/Plugins/Language/Rust/RustLanguage.cpp#L292 rel=noopener target=_blank>disgusting hack</a> that hijacks an unrelated function to accomplish that, but that really shouldn't be necessary</div><footer class=post-footer><ul class=post-tags><li><a href=https://walnut356.github.io/tags/programming/>programming</a><li><a href=https://walnut356.github.io/tags/rust/>rust</a><li><a href=https://walnut356.github.io/tags/debugging/>debugging</a></ul><nav class=paginav><a class=prev href=https://walnut356.github.io/posts/so-you-want-better-debug-info/> <span class=title>« Prev</span> <br> <span>So you want better debug info?</span> </a><a class=next href=https://walnut356.github.io/posts/lldbs-typesystems-pt-2/> <span class=title>Next »</span> <br> <span>LLDB's TypeSystems Part 2: PDB</span> </a></nav></footer></article></main><footer class=footer><span>© 2025 <a href=https://walnut356.github.io>Walnut356</a></span><span> Powered by <a rel="noopener noreferrer" href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/cydave/zola-theme-papermod rel=noopener target=_blank>PaperMod</a> </span></footer><a aria-label="go to top" title="Go to Top (Alt + G)" accesskey=g class=top-link href=#top id=top-link> <svg viewbox="0 0 12 6" fill=currentColor xmlns=http://www.w3.org/2000/svg><path d="M12 6H0l6-6z"/></svg> </a><script>let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });</script><script>var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };</script><script>document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })</script><script>document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';
        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                var content = codeblock.textContent;
                if(codeblock.firstChild.tagName == 'TABLE') {
                    content = Array(...codeblock.firstChild.getElementsByTagName('span')).map((span) => { return span.textContent; }).join('');
                }
                navigator.clipboard.writeText(content);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            // td containing LineNos
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            // table containing LineNos and code
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            // code blocks not having highlight as parent class
            codeblock.parentNode.appendChild(copybutton);
        }
    });</script>