<!doctype html><html dir=auto lang=en><head><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content="index, follow" name=robots><title>TwoVec: A Very Silly Container</title><meta name=keywords><meta name=description><meta content=Walnut356 name=author><link href=https://walnut356.github.io/posts/twovec-a-very-silly-container/ rel=canonical><link href=/styles.css rel=stylesheet><link href=/override.css rel=stylesheet><link href=/syntax-theme.css rel=stylesheet><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel=stylesheet><link crossorigin href=/CascadiaCode-Regular.woff2 rel=font><link href=/favicon.png rel=icon type=image/x-icon><link href=https://walnut356.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src="https://www.googletagmanager.com/gtag/js?id=G-PKLX5VEB4H" async></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PKLX5VEB4H');</script><body class=dark id=top><script>if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }</script><header class=header><nav class=nav><div class=logo><a title="Cracking The Shell (Alt + H)" accesskey=h href=https://walnut356.github.io> Cracking The Shell </a><div class=logo-switches><button title="(Alt + T)" accesskey=t id=theme-toggle><svg viewbox="0 0 24 24" fill=none height=18 id=moon stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> <svg viewbox="0 0 24 24" fill=none height=18 id=sun stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></button><ul class=lang-switch><li></ul></div></div><ul id=menu><li><a href=https://walnut356.github.io/archive title=Archive> <span>Archive</span> </a><li><a href=https://walnut356.github.io/search title=Search> <span>Search</span> </a><li><a href=https://walnut356.github.io/tags title=Tags> <span>Tags</span> </a></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://walnut356.github.io>Home</a> »  <a href=https://walnut356.github.io/posts/>Posts</a> »  <a href=https://walnut356.github.io/posts/twovec-a-very-silly-container/>TwoVec: A Very Silly Container</a></div><h1 class=post-title>TwoVec: A Very Silly Container</h1><div class=post-meta><span title="2024-10-18 00:00:00 +0000">2024-10-18</span> · 21 min · 4093 words</div></header><div class=toc><details><summary title="(Alt + C)" accesskey=c><span class=details>Table of Contents</span></summary> <div class=inner><ul><li><a aria-label="How it works" href=#how-it-works>How it works</a> <ul><li><a aria-label="Crimes against debugability" href=#crimes-against-debugability>Crimes against debugability</a><li><a aria-label="Crimes against the type system" href=#crimes-against-the-type-system>Crimes against the type system</a><li><a aria-label="Bit Fiddling" href=#bit-fiddling>Bit Fiddling</a></ul><li><a aria-label=Limitations href=#limitations>Limitations</a> <ul><li><a aria-label=Speed href=#speed>Speed</a><li><a aria-label=Traits href=#traits>Traits</a><li><a aria-label=Space href=#space>Space</a></ul><li><a aria-label="But why?" href=#but-why>But why?</a></ul></div></details></div><div class=post-content><p>Lets say you want to store two different types of objects in 1 container. Simple right? Just slap those puppies in a tuple and you're good to go:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Vec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-storage z-type z-primitive z-rust">f32</span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-support z-macro z-rust">vec!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">255</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-constant z-numeric z-float z-rust">20.0</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">10</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-constant z-numeric z-float z-rust">37.0</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><p>But what if you wanted to include elements of two different types in <em>arbitrary orders</em>? Thankfully, there's sum types for that:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-enum z-rust"><span class="z-storage z-type z-enum z-keyword z-rust">enum</span> <span class="z-meta z-enum z-rust"><span class="z-entity z-name z-enum z-rust">Val</span></span></span><span class="z-meta z-enum z-rust"> <span class="z-meta z-block z-rust"><span class="z-meta z-enum z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span></span></span></span><span class="z-meta z-block z-rust"><span class="z-meta z-enum z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-enum z-rust">    <span class="z-constant z-other z-rust">A</span><span class="z-meta z-struct z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-primitive z-rust">u8</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-enum z-rust">    <span class="z-constant z-other z-rust">B</span><span class="z-meta z-struct z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-primitive z-rust">f32</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-enum z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-keyword z-operator z-range z-rust">...</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">list</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-support z-macro z-rust">vec!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-storage z-type z-rust">Val</span><span class="z-punctuation z-accessor z-rust">::</span><span class="z-entity z-name z-constant z-rust">A</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">255</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-storage z-type z-rust">Val</span><span class="z-punctuation z-accessor z-rust">::</span><span class="z-entity z-name z-constant z-rust">B</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-float z-rust">20.0</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-storage z-type z-rust">Val</span><span class="z-punctuation z-accessor z-rust">::</span><span class="z-entity z-name z-constant z-rust">B</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-float z-rust">37.0</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-storage z-type z-rust">Val</span><span class="z-punctuation z-accessor z-rust">::</span><span class="z-entity z-name z-constant z-rust">A</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">10</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></code></pre><p>One small problem. That's <em>wasteful</em>.</p><span id=continue-reading></span><p>We have 2 variants that cannot be niche optimized, and the variants are different sizes. Since <code>Val</code> itself must have 1 known size, smaller variants are required to add pad bytes to match the size of the largest variant. Additionally, since default Rust struct layout guarantees that the alignment of a struct is at least the maximum of all of its fields, the <code>f32</code> contained in <code>Val::B</code> forces all <code>Val</code>s to be 4-byte aligned. That means even with <code>#[repr(u8)]</code>, a <code>Val::A(u8)</code> is <em>64 bits in size</em>, despite it being possible to represent all <code>Val</code>s with only 5 bytes, and all <code>Val::A(u8)</code>'s with only 1 byte + 1 bit. <code>Val::B(f32)</code> is less wasteful, as only ~48% of its bits are complete dead weight, but it's still a sad number.<p>Not to worry, I know RAM is the most precious of commodities in 2024 so I've come up with the answer to your woes. The <code>TwoVec</code>:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">x</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-storage z-type z-numeric z-rust">u8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">y</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-constant z-numeric z-float z-rust">20.0</span><span class="z-storage z-type z-numeric z-rust">f32</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> type inference from .push_a and .push_b
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">list</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-storage z-type z-source z-rust">TwoVec</span><span class="z-method z-rust"><span class="z-punctuation z-accessor z-rust">::</span><span class="z-variable z-function z-rust">new</span></span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> dedicated functions
</span></span><span class="z-source z-rust"><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">push_a</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">x</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">push_b</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">y</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> or through type inference
</span></span><span class="z-source z-rust"><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">push</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-float z-rust">18.0</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">push</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">17</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">push</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">12</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">push</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-float z-rust">35.7</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">push</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">dbg!</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-operator z-bitwise z-rust">&</span><span class="z-variable z-local z-rust">list</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> in bytes
</span></span><span class="z-source z-rust"><span class="z-support z-macro z-rust">dbg!</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">capacity</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> returns Some(val) if the value at that index is the correct type
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">v</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">0</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">dbg!</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">v</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> returns None when the value is not the correct type
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">w</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-primitive z-rust">f32</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">0</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">dbg!</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">w</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-variable z-local z-rust">w</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">list</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">dbg!</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">w</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><pre class="language-txt z-code" data-lang=txt><code class=language-txt data-lang=txt><span class="z-text z-plain">[Output]
</span><span class="z-text z-plain">&list = TwoVec[8, 20.0, 18.0, 17, 12, 35.7, 1]
</span><span class="z-text z-plain">list.capacity() = 18
</span><span class="z-text z-plain">v = Some(8,)
</span><span class="z-text z-plain">w = None
</span><span class="z-text z-plain">w = Some(20.0,)
</span></code></pre><p>In the above example, I made sure to exactly fill the current allocation size of <code>list</code>. That means the listed capacity (18 bytes) minus the size of the data is the amount of overhead for bookkeeping. 4 <code>u8</code>s and 3 <code>f32</code>s takes up 16 bytes total, so we only have a storage overhead of 2 bytes! Compared to the <code>Val</code> enum above, that's a savings of 30 bytes.<p>The source code is available <a href=https://github.com/Walnut356/twovec rel=noopener target=_blank>here</a>, and the <a href=https://crates.io/crates/twovec rel=noopener target=_blank>crate is available on crates.io</a><h2 id=how-it-works>How it works<a aria-hidden=true class=anchor hidden href=#how-it-works>#</a></h2><p>The basics are pretty simple, but getting it to work in Rust's type system was a bit of an adventure.<p>To get the basis of the container out of the way as quickly as possible: array indexing is nothing but a base pointer + an offset. Arrays themselves are nothing more than an arbitrary region of bytes, regardless of what type they're "assigned" (see: C's <code>void*</code>). Types are only "real" at compile time. Having arrays that contain only 1 type - or ensuring that all types contained in the array are the same size like enums do - allows for consistent and universal indexing math. That being said, if you can figure out the offsets on your own, there's nothing stopping you from implementing the indexing logic yourself. In a sense, hashmaps already work based on this principle.<p>We only have two states, easily represented by a single bit. We know the size of both of the types, so we should be able to calculate the byte-offset ourselves by counting the number of each type and multiplying it by its respective size. We can start with a struct very similar to a standard <code>Vec</code>:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-keyword z-rust">struct</span> <span class="z-meta z-struct z-rust"><span class="z-meta z-generic z-rust"><span class="z-entity z-name z-struct z-rust">TwoVec</span></span></span></span><span class="z-meta z-struct z-rust"><span class="z-meta z-generic z-rust"><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span></span><span class="z-meta z-struct z-rust"> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">len</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">capacity</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">bitfield</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">NonNull</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">data</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">NonNull</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">a</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">PhantomData</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">b</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">PhantomData</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><h3 id=crimes-against-debugability>Crimes against debugability<a aria-hidden=true class=anchor hidden href=#crimes-against-debugability>#</a></h3><p>You might notice that there's only 1 <code>capacity</code> and 1 <code>len</code>, despite there being 2 pointers do data. Since RAM is at a premium, we clearly can't store our bookkeeping bits in a <em>different</em> region of memory. Just think of the wasted allocator metadata bytes. As the old saying goes: "Only 1 allocation for this rustacean". This increases the bookkeeping complexity by a bit, but at least we can now say we're storing <em>three</em> different types in a single allocation instead of just 2.<p>This has a substantially negative impact on the debugging experience, since now it's possible to overwrite bookkeeping data with element data and vice versa if we fuck up our indexing math. Which I definitely didn't do like 5 separate times. And when yo- <em>ahem</em> <strong>if</strong> you fuck up, have fun debugging bitfields and packed, probably unaligned values. Just awful. I definitely do not speak from experience though.<p>Just for sake of example, imagine a few of the bits being set incorrectly due to an off-by-one error. Suddenly, your pretty-printer for the data block isn't just interpreting the bytes as the wrong value. The offset of the <em>next</em> value is partially based on the size of the one we have. If we interpret that size wrong, we're now jumping to the wrong location <strong>and</strong> even if we weren't, there's a good chance we're interpreting the bytes there as the wrong type too. The debugger display (at least, the one I was using) is largely unhelpful as well since an <code>unsigned char*</code> is interpreted as a C string. Hope you didn't have any <code>\0</code> bytes in your data anywhere or you only get to see fraction of the total block =)<p>Reading listings that looks like this<pre class="language-text z-code" data-lang=text><code class=language-text data-lang=text><span class="z-text z-plain">{pointer:"\xba]B\xe3;?e7&z\\\U00000011\xbe\xcb\xd2>\xf9;5?3T"}
</span></code></pre><p>and trying to extract useful information about why things went wrong is a special kind of pain. Again, not that I speak from experience or anything.<p>Anyway, upon the first allocation of a data block, typical <code>Vec</code> implementations will reserve space for a handful of elements to reduce the number of times the <code>Vec</code> needs to be <code>realloc</code>'d. In our case, it's not so simple. If we reserve 8 spots for <code>f32</code>s + 1 additional byte for the bitfield, we run into a problem. If we filled the <code>TwoVec</code> with <code>u8</code>s, we wouldn't have enough bits to tag them all - 8 <code>f32</code>s takes the same space as <em>32</em> <code>u8</code>s. We always need to make sure we have enough bits to cover the worst-possible case:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> "base" size of the allocation, taken from rust's `RawVec` implementation
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">base_size</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">MAX_A_B</span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">MIN_NON_ZER0_CAPACITY</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> number of bits needed to represent the "worst case" (i.e. 100% of capacity filled with the smaller element)
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">max_elements</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">base_size</span> <span class="z-keyword z-operator z-arithmetic z-rust">/</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">MIN_A_B</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">bitfield_size</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">max_elements</span> <span class="z-keyword z-operator z-arithmetic z-rust">/</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">new_capacity</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">base_size</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-variable z-local z-rust">bitfield_size</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">new_layout</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-storage z-type z-source z-rust">Layout</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">array<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">new_capacity</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">unwrap</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><p>On each reallocation, we double the number of elements that can be stored, which exactly doubles the number of degenerate-case slots. Thus we don't have to worry about further fiddling with the bitfield size after the initial allocation, doubling the whole capacity suffices.<p>Unfortunately, that brings up another issue. We cannot simply call <code>realloc</code>. <code>realloc</code> automatically copies all of the old bytes into the new allocation. In <code>TwoVec</code>, the distance between the start of the bitfield and the start of the data block is not static, it grows when the allocation grows. That means we need to manually copy the data over in two steps, leaving an extra gap for the new bitfield bytes<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">unsafe</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">offset</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">data</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">offset_from</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">bitfield</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">usize</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">bitfield</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">copy_to_nonoverlapping</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">new_ptr</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-local z-rust">offset</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">new_data</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">new_ptr</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">add</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">bitfield_size</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">data</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">copy_to_nonoverlapping</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">new_data</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">capacity</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-variable z-local z-rust">offset</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-function z-rust">dealloc</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">bitfield</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">as_ptr</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-source z-rust">Layout</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">array<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">capacity</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">unwrap</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-punctuation z-section z-group z-end z-rust">)</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></code></pre><h3 id=crimes-against-the-type-system>Crimes against the type system<a aria-hidden=true class=anchor hidden href=#crimes-against-the-type-system>#</a></h3><p>The <code>get</code> and <code>push</code> functions require 2 different implementations because we need to be able to detect if the type we're asking for matches the value of the type-bit. i.e. if we want a <code>B</code>, we have to check if the bit is <code>1</code>, but if we want an <code>A</code>, we have to check if the bit is a <code>0</code>. It <em>might</em> be possible to pull this off dynamically in 1 function, but we still have another issue.<p>Those with a keen eye may have heard some alarm bells when I showed off the type inference of the <code>get</code> and <code>push</code> methods. After all, if they were defined as<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span></span><span class="z-meta z-impl z-rust"><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-entity z-name z-impl z-rust">TwoVec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">T</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">T</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span><span class="z-keyword z-operator z-range z-rust">...</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>We suddenly have a <em>very</em> big safety hole. Rust's type system can express exactly 2 relationships between <em>types</em>. <code>TwoVec&LTA, A></code> is a <code>TwoVec</code> whose elements are <em>always</em> of type <code>A</code>. Conversely, <code>TwoVec&LTA, B></code> means that elements may be of type <code>A</code> or type <code>B</code>, and that <code>A</code> <em>might</em> be the same as type <code>B</code>, but also might not. There is no way to indicate that two types must <em>not</em> be the same. There is also no way to guarantee that a third type (<code>T</code> in this case) <em>is</em> <code>A</code> or <code>B</code>.<p>Imagine we have a completely full <code>TwoVec&LTA, B></code> and we access the last element with our <code>get</code> function. Except we forget what type <code>A</code> is, and call <code>get</code> with a type where <code>size_of::&LTT>() > size_of::&LTA>()</code>. Since this whole house of cards functions via pointer casting, there is nothing stopping this from reading out-of-bounds memory. Even if we added a check (e.g. <code>if ptr_to_elmt + size_of::&LTT>() > ptr_to_end_of_alloc</code>) we're still giving people an "unsafe-free" <code>mem::transmute()</code>.<p>We could try declaring the function <code>get&LTA></code> <em>or</em> <code>get&LTB></code>, but now it only works for one of our two types which isn't ideal. Instead, we can try using a <code>Get&LTT></code> trait to accomplish this.<p>There's a problem when we add the <code>impl</code>s though:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span></span><span class="z-meta z-impl z-rust"><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">Get</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-entity z-name z-impl z-rust">TwoVec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-keyword z-other z-self z-rust">self</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-operator z-range z-rust">...</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span></span><span class="z-meta z-impl z-rust"><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">Get</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-entity z-name z-impl z-rust">TwoVec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span> <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Error, overlapping impls
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-keyword z-other z-self z-rust">self</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-operator z-range z-rust">...</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>Because <code>A</code> and <code>B</code> <em>could</em> be the same type, the compiler wouldn't know which <code>impl</code> to choose. We, as the programmer, know that it doesn't even make sense for a <code>TwoVec</code> to be used when <code>A</code> and <code>B</code> are the same type - <code>TwoVec&LTA, A></code> is strictly worse than just using <code>Vec&LTA></code> - but there's no way to express this via a trait on <code>TwoVec</code>.<p>A bare marker trait on the types themselves also doesn't quite work.<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-trait z-rust"><span class="z-storage z-type z-trait z-rust">trait</span> <span class="z-entity z-name z-trait z-rust">MarkerA</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">tv</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-other z-self z-rust">Self</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-trait z-rust"><span class="z-storage z-type z-trait z-rust">trait</span> <span class="z-entity z-name z-trait z-rust">MarkerB</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-other z-self z-rust">Self</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span> </span><span class="z-meta z-impl z-rust"><span class="z-identifier z-rust">MarkerA</span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-entity z-name z-impl z-rust">u8</span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span><span class="z-keyword z-operator z-range z-rust">...</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span> </span><span class="z-meta z-impl z-rust"><span class="z-identifier z-rust">MarkerB</span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-entity z-name z-impl z-rust">f32</span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span><span class="z-keyword z-operator z-range z-rust">...</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>Aside from the fact that the user must now define these marker traits, we also have the issue that there's no negative <code>trait</code> bounds (outside of the compiler) either! A type could easily implement <code>MarkerA</code> <em>and</em> <code>MarkerB</code> and it still wouldn't know which version to call. Even if we somehow bypassed that restriction and make the traits mutually exclusive, we cannot have <code>TwoVec&LTu8, f32></code> and <code>TwoVec&LTf32, u8></code> in the same program because <code>u8</code> would be required to impl <code>MarkerA</code> for the former and <code>MarkerB</code> for the latter.<p>It took me quite a bit of fiddling to work around this issue. I tried lots of <code>AsRef</code> and deref-abuse shenanigans, some unstable features, lots of different things on both the <code>TwoVec</code> itself and on its constituent types. Many things <em>kindof</em> work, but require the <a href=https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name rel=noopener target=_blank>fully qualified syntax</a> which is... not preferable for obvious reasons. I have half an RFC written out of pure frustration titled <code>negative_type_bounds</code>. Being able to specify <code>pub struct TwoVec&LTA, B> where A: !B</code> (or type subsets like <code>fn get&LTT: A | B></code>) would make this significantly easier. As far as I know, that sort of thing is trivial with C++'s templates.<p>I found one way to make things work, and it's const generics (though there are lots of ways that <em>don't</em> work with const generics and unstable <code>generic_const_expr</code>, maybe a story for another day). By including a const <code>bool</code> type parameter on a trait implemented on each <em>type</em> <code>A</code> and <code>B</code>, we can differentiate between <code>&LTA, B></code> where <code>A</code> is important and <code>&LTA, B></code> where <code>B</code> is important. We can blanket-impl this trait to every <code>Sized</code> type:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-trait z-rust"><span class="z-storage z-type z-trait z-rust">trait</span> <span class="z-entity z-name z-trait z-rust">Gettable</span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-storage z-modifier z-rust">const</span> <span class="z-identifier z-rust">Z</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">bool</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span>
</span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-where z-rust"><span class="z-keyword z-other z-rust">where</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-where z-rust">    <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-support z-type z-rust">Sized</span>,
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-where z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">tv</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">TwoVec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-other z-self z-rust">Self</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-trait z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span></span><span class="z-meta z-impl z-rust"><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">Gettable</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-constant z-language z-rust">false</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-entity z-name z-impl z-rust">A</span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">tv</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">TwoVec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-other z-self z-rust">Self</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-variable z-local z-rust">tv</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get_a</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span></span><span class="z-meta z-impl z-rust"><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">Gettable</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-constant z-language z-rust">true</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-entity z-name z-impl z-rust">B</span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">tv</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">TwoVec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-other z-self z-rust">Self</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-variable z-local z-rust">tv</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get_b</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>From there, it's possible to add a function <code>get&LTT, const Z: bool></code> in <code>TwoVec</code> with the bound <code>where T: Gettable&LTA, B, Z></code>. Not only does this restrict to only the exact types <code>A</code> and <code>B</code> of <code>TwoVec&LTA, B></code>, it also does not conflict with <code>TwoVec&LTB, A></code>, since that is an entirely different type from <code>TwoVec&LTA, B></code>. Technically, when turbofishing <code>get</code> you're now required to also include the const bool parameter, but in most cases this is unnecessary because type inference removes the need for a turbofish at all.<p>To clarify further, since this is sorta spaghetti, here's an example. Say you have <code>TwoVec&LTu8, f32></code><ul><li>When asking for an <code>Option&LTu8></code>, the compiler sees that <code>u8</code> is <code>Gettable</code> for <code>u8, f32, true</code>, and the function signature requires a <code>TwoVec&LTu8, f32></code>. There is no <code>Gettable</code> with <code>u8, f32, false</code>, as <code>false</code> is only cares about the <code>B</code> parameter, and <code>u8 != f32</code>. There is no other <code>Gettable</code> implementation for <code>u8</code> with valid criteria, thus the const parameter <code>true</code> can be assumed<li><code>TwoVec&LTu8, f32></code> impls cannot overlap with, say, <code>TwoVec&LTu8, i64></code> because the <code>B</code> parameter of <code>i64</code> (and the <code>TwoVec&LTu8, f32></code> in the function signature) would place it in an entirely different monomorphization of <code>Gettable</code><li>There is no self-overlap with <code>TwoVec&LTu8, u8></code> because <code>Gettable&LTA, B, false></code> and <code>Gettable&LTA, B, true></code> are mutually exclusive (even though in this case they'd be completely interchangeable). Interestingly, type inference doesn't require us to turbofish on a <code>TwoVec&LTA, A></code> even though both implementations would be valid. I'm not sure whether the compiler is choosing <code>get::&LTu8, true>()</code> or <code>get::&LTu8, false>()</code> or how it even makes the decision. Weird. <strong>Edit:</strong> Whoops, it definitely does ask for the generic parameter, not sure how I concluded otherwise.</ul><p>Grimy? Yes. Cool? Arguably.<p>We can even add a third impl that returns an <code>either::Either</code>, though this one feels even more gross since now the const parameter is truly meaningless (though it still must be a definite value for type inference to work)<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-storage z-type z-impl z-keyword z-rust">impl</span></span><span class="z-meta z-impl z-rust"><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-support z-type z-rust">Copy</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-support z-type z-rust">Copy</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">Gettable</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-constant z-language z-rust">true</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> <span class="z-keyword z-other z-rust">for</span></span><span class="z-meta z-impl z-rust"> <span class="z-meta z-generic z-rust"><span class="z-entity z-name z-impl z-rust">Either</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span> </span><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">get</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">tv</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-meta z-generic z-rust"><span class="z-storage z-type z-any z-rust">TwoVec</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-identifier z-rust">B</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-keyword z-other z-self z-rust">Self</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-control z-rust">if</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-comparison z-rust">></span> <span class="z-variable z-local z-rust">tv</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">len</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-keyword z-control z-rust">return</span> <span class="z-support z-type z-variant z-rust">None</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-control z-rust">if</span> <span class="z-variable z-local z-rust">tv</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">is_a</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-variable z-local z-rust">tv</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get_a</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">map</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">|</span></span></span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-variable z-parameter z-rust">x</span><span class="z-punctuation z-section z-parameters z-end z-rust">|</span></span> </span><span class="z-meta z-function z-closure z-rust"><span class="z-storage z-type z-rust">Either</span><span class="z-punctuation z-accessor z-rust">::</span><span class="z-storage z-type z-enum z-rust">Left</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">x</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span> <span class="z-keyword z-control z-rust">else</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-variable z-local z-rust">tv</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get_b</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">map</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">|</span></span></span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-variable z-parameter z-rust">x</span><span class="z-punctuation z-section z-parameters z-end z-rust">|</span></span> </span><span class="z-meta z-function z-closure z-rust"><span class="z-storage z-type z-rust">Either</span><span class="z-punctuation z-accessor z-rust">::</span><span class="z-storage z-type z-enum z-rust">Right</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">x</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-impl z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><h3 id=bit-fiddling>Bit Fiddling<a aria-hidden=true class=anchor hidden href=#bit-fiddling>#</a></h3><p>As I mentioned above, debugging this nonsense is the <em>worst</em>. Typical debugger utilities are borderline worthless, so I have to check a lot of things by hand. As in notebook, pen, ascii table, and programming calculator, hand-translating whatever the debugger gave me into a slightly more useable form data at each step in the algorithm, drawing diagrams and painstakingly proving to myself each individual piece makes sense.<p>I want to walk through the implementation of the <code>remove</code> function to give you guys an idea how much more fiddly this is compared to <code>Vec</code> functions. <code>remove</code> has to do two distinct tasks to work properly:<ol><li>copy the data from the region <code>offset_of_next_element..end_offset</code> to the region <code>offset_of_element..end_offset_minus_size_of_removed_element</code><li>take every bitfield-bit <em>after</em> the index and bitshift it left once</ol><p>The first part is easy - we can copy the <code>std::Vec</code> implementation almost exactly. The only difference is that we can't just subtract "1 element" from the end offset, we have 2 different kinds of elements.<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">remove_a</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-storage z-modifier z-rust">mut</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-control z-rust">if</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-comparison z-rust">></span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">len</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-support z-macro z-rust">panic!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">"</span>Cannot remove value at index <span class="z-constant z-other z-placeholder z-rust">{idx}</span>, length is <span class="z-constant z-other z-placeholder z-rust">{}</span><span class="z-punctuation z-definition z-string z-end z-rust">"</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-separator z-rust">,</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">len</span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-control z-rust">if</span> <span class="z-keyword z-operator z-logical z-rust">!</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">is_a</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-control z-rust">return</span> <span class="z-support z-type z-variant z-rust">None</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">val_offset</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">idx_to_offset</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">end_offset</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">idx_to_offset</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">len</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">out</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-meta z-generic z-rust"><span class="z-support z-type z-rust">Option</span><span class="z-punctuation z-definition z-generic z-begin z-rust"><</span><span class="z-identifier z-rust">A</span><span class="z-punctuation z-definition z-generic z-end z-rust">></span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-modifier z-rust">unsafe</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">ptr</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">data</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">add</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">val_offset</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-variable z-local z-rust">out</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-support z-type z-variant z-rust">Some</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">ptr</span><span class="z-punctuation z-accessor z-dot z-rust"><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">cast</span><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-keyword z-operator z-comparison z-rust"><</span><span class="z-storage z-type z-rust">A</span><span class="z-keyword z-operator z-comparison z-rust">></span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">read_unaligned</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-variable z-local z-rust">ptr</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">copy_from</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-variable z-local z-rust">ptr</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">add</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">A_SIZE</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-variable z-local z-rust">end_offset</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">val_offset</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">A_SIZE</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-punctuation z-section z-group z-end z-rust">)</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">shift_bits_down_after</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-local z-rust">out</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>That <code>shift_bits_down_after</code> function call is carrying a lot of weight though. I always jump right to the bit fiddling solution, but I ended up messing it up on my first go-round. I took the time to make this slower, simpler function first to test against:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-keyword z-control z-rust">for</span> <span class="z-variable z-local z-rust">i</span> <span class="z-keyword z-operator z-rust">in</span> <span class="z-variable z-local z-rust">idx</span><span class="z-keyword z-operator z-range z-rust">..</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">len</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">b</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get_bit</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">i</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-keyword z-control z-rust">if</span> <span class="z-variable z-local z-rust">b</span> <span class="z-keyword z-operator z-comparison z-rust">==</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">0</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">clear_bit</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">i</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span> <span class="z-keyword z-control z-rust">else</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">set_bit</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">i</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></code></pre><p>Before we get into the indexing math, I want to point out something small. In an effort to make debugging a little bit less painful the bit indexes are "reversed" so that the whole bitfield slice pretty-prints in order. That means the bit set to <code>1</code> in the expressions <code>1 << 7</code> or <code>0b1000_0000</code> is at index <code>0</code>. The <code>clear_</code>, <code>set_</code> and <code>get_</code> functions all follow this same pattern:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">set_bit</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-storage z-modifier z-rust">mut</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">byte_idx</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">/</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">bit_idx</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">%</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">bf</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">bitfield_mut</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-local z-rust">bf</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-local z-rust">byte_idx</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span> <span class="z-keyword z-operator z-assignment z-rust">|=</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span> <span class="z-keyword z-operator z-bitwise z-rust"><<</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">7</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-variable z-local z-rust">bit_idx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>To lump multiple of these together into bit-shift operations, we need to handle 2 separate steps<ol><li>for the byte that <code>idx</code> falls in, we need to left-shift <em>only</em> the bits after <code>idx</code><li>for that byte and all (potential) following bytes, we need to fill the new "blank" right-most bit. The value that goes here is the left-most value of the next byte in the bitfield</ol><p>As an aside, since the carry bit comes from the previous shift instruction, the most efficient way to handle this would probably be to iterate through the bitfield <em>backwards</em>. This is because the shift instructions automatically store the last-shifted-out-bit in a special, non-general-purpose register. Once there, it can be passed to the next operation for free - no register or stack usage required. On the other hand, computers aren't optimized for reverse-order array access, which typically wrecks the cache prefetch predictions. On the other <em>other</em> hand, that probably only matters if the bitfield is larger than a cache line (typically 64 bytes, which is 512 elements). On the other <em>other</em> <strong>other</strong> hand, it might be that the compiler can "see through" what I'm doing and rearrange the operations such that it uses the carry flag regardless of the order I read the array. For the sake of my sanity, I'm just going to iterate through it front to back.<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">bf</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">bitfield_mut</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">start_byte_idx</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">/</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">start_bit_idx</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">%</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">idx_byte</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">bf</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-local z-rust">start_byte_idx</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><p>Next we need to isolate the 2 sets of bits we want - the bits before <code>idx</code> and the bits after <code>idx</code>. This is a bit trickier than it sounds though, since we also need to shift off <code>idx</code> itself. When shifting off the bottom bits, the naive shift amount might be <code>7 - (idx + 1)</code>, but this will panic if <code>idx == 7</code> due to subtraction overflow. While we could do something like <code>7.saturating_sub(start_bit_idx + 1)</code>, this doesn't quite have the behavior we want. If <code>idx == 7</code> and our byte is <code>0b0000_0001</code>, the prior formula will give us a bitshift of 0 and our value won't change.<p>Workarounds for that like <code>7.checked_sub(start_bit_idx + 1).unwrap_or(1)</code> or <code>7.saturating_sub(start_bit_idx + 1).max(1)</code> only work when <code>idx > 0</code>. When <code>idx == 0</code>, the only right-shift that would clear the top bit is 8. Unfortunately, shifting with a value that is >= the bitwidth of your integer is UB.<p>While we could make that a special case (<code>if start_bit_idx != 0 {...}</code> or <code>checked_shr</code>), it's easier to just shift it by the base amount, shift that value by 1, and then do the same in reverse. Alternatively, since we're dealing in non-<code>usize</code> values, we could cast the value to a larger size during the bit fiddling and then <code>as</code> cast it back to a <code>u8</code> (which truncates it in rust) when it comes time to store the value. Casting more or less compiles to a noop so it's probably a smidge faster than 2 bitshifts.<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> clears all the bits including and after idx
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">shift_amt</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-variable z-local z-rust">start_bit_idx</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">pre_idx_bits</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx_byte</span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">u32</span> <span class="z-keyword z-operator z-bitwise z-rust">>></span> <span class="z-variable z-local z-rust">shift_amt</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-bitwise z-rust">>></span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-punctuation z-section z-group z-end z-rust">)</span> <span class="z-keyword z-operator z-bitwise z-rust"><<</span> <span class="z-variable z-local z-rust">shift_amt</span><span class="z-punctuation z-section z-group z-end z-rust">)</span> <span class="z-keyword z-operator z-bitwise z-rust"><<</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-punctuation z-section z-group z-end z-rust">)</span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> clears all the bits up to and including idx. Requires a +1 because bits are
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> "0-indexed" when shifting. When shifting back, we drop the +1 so that we can
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> overwrite the bit that's being removed
</span></span><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">post_idx_bits</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">idx_byte</span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">u32</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-bitwise z-rust"><<</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">start_bit_idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">u8</span><span class="z-punctuation z-section z-group z-end z-rust">)</span> <span class="z-keyword z-operator z-bitwise z-rust">>></span> <span class="z-variable z-local z-rust">start_bit_idx</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><p>One very important note: the cast to u8 for the pre index bits <strong>must</strong> be done <em>after</em> both shifts, since both shifts could overflow. The cast to u8 for the post index bits <strong>must</strong> be done <em>before</em> the second shift, because we need to truncate off the top bits before sliding everything back into place. I mistakenly did the truncation after both shifts and it took me an embarrassingly long time to spot.<p>With this done, we've effectively "closed the gap" by removing a bit, and the right-most bit in the pre- and post-idx values should be 0. Next we just need the carry bit, which can default to 0 if there is no next byte.<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">carry</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">bf</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">start_byte_idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">cloned</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">unwrap_or_default</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-bitwise z-rust">>></span> <span class="z-constant z-numeric z-integer z-decimal z-rust">7</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><p>and the resultant value is all 3 of those values masked together<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-variable z-local z-rust">bf</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-local z-rust">start_byte_idx</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">pre_idx_bits</span> <span class="z-keyword z-operator z-bitwise z-rust">|</span> <span class="z-variable z-local z-rust">post_idx_bits</span> <span class="z-keyword z-operator z-bitwise z-rust">|</span> <span class="z-variable z-local z-rust">carry</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre><p>And finally, we can handle the rest of the bytes (if there are any) with a straightforward loop:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-keyword z-control z-rust">for</span> <span class="z-variable z-local z-rust">i</span> <span class="z-keyword z-operator z-rust">in</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-keyword z-operator z-range z-rust">..</span><span class="z-variable z-local z-rust">bf</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">len</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">x</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">bf</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-local z-rust">i</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-local z-rust">carry</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">bf</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">get</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">i</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">cloned</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">unwrap_or_default</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-bitwise z-rust">>></span> <span class="z-constant z-numeric z-integer z-decimal z-rust">7</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-local z-rust">bf</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-local z-rust">i</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">x</span> <span class="z-keyword z-operator z-bitwise z-rust"><<</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-bitwise z-rust">|</span> <span class="z-variable z-local z-rust">carry</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></code></pre><p>All of that just to accomplish the same feat as a single line in the <code>Vec::remove</code> implementation.<h2 id=limitations>Limitations<a aria-hidden=true class=anchor hidden href=#limitations>#</a></h2><h3 id=speed>Speed<a aria-hidden=true class=anchor hidden href=#speed>#</a></h3><p>Let's get this out of the way right away, on benchmarks pushing/reading/removing 10,000 random elements with random types, <code>TwoVec</code> is ~100x slower than <code>Vec&LTEnum></code>.<p><code>.idx_to_offset()</code> - the primary driver for accessing the data - is technically <code>O(N)</code>, but is really <code>O(N/64)</code> (yes I know how Big O works, but as far as I'm aware most people aren't adding an infinite number of elements to their vector so the coefficient still matters). This is after some optimizations. The original implementation looked something like this:<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> <span class="z-entity z-name z-function z-rust">idx_to_offset</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-keyword z-operator z-symbol z-rust">&</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-parameter z-rust">idx</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-></span> <span class="z-storage z-type z-primitive z-rust">usize</span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">byte_count</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">/</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">bit_count</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">%</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">bitfield</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-storage z-modifier z-rust">unsafe</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-variable z-function z-rust">slice_from_raw_parts</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-other z-self z-rust">self</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-local z-rust">bitfield</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">as_ptr</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-local z-rust">byte_count</span><span class="z-punctuation z-section z-group z-end z-rust">)</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">                <span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">as_ref</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">                <span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">unwrap</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">slice</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-constant z-numeric z-integer z-decimal z-rust">0</span><span class="z-storage z-type z-numeric z-rust">u8</span><span class="z-punctuation z-separator z-rust">;</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">result</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-primitive z-rust">usize</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">bitfield</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">            <span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">iter</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">            <span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">map</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">|</span></span></span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-variable z-parameter z-rust">x</span><span class="z-punctuation z-section z-parameters z-end z-rust">|</span></span> </span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-block z-rust">                <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">a_count</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">x</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">count_zeros</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">usize</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-block z-rust">                <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">a_count</span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">A_SIZE</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">8</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-variable z-local z-rust">a_count</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">B_SIZE</span><span class="z-punctuation z-section z-group z-end z-rust">)</span>
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-block z-rust">            </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">            <span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">sum</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-control z-rust">if</span> <span class="z-variable z-local z-rust">bit_count</span> <span class="z-keyword z-operator z-comparison z-rust">==</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">0</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-keyword z-control z-rust">return</span> <span class="z-variable z-local z-rust">result</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> handling for the remaining partial u8
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-operator z-range z-rust">...</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre><p>Essentially, it takes the slice <code>bitfield[..bitfield.len() - 1]</code> and iterates over it, using <code>.count_ones()</code>/<code>.count_zeroes()</code> (which compile down to ~a single <code>popcnt</code> instruction) to determine how many of each type of element there is. A final special case has to be handled when <code>idx</code> doesn't fall on a byte boundary.<p>This code gets vectorized by the compiler. As it turns out though, the vectorized code is slightly suboptimal. In my benchmark, it ran a fair bit faster with <code>#[inline(never)]</code>, but even that was slow. I'm not sure if it's the inherent performance characteristics of the vector instructions, the degenerate cases where the whole vector register is loaded up just to check 1 bit, the algorithm used to emulate <code>popcnt</code> behavior, or some other factor that I'm not considering. In any case, using "shitty simd", (i.e. treating a <code>u64</code> as packed <code>u8</code>s) was about 20% faster on <code>push</code> and <code>get</code> for reasonable numbers of elements.<pre class="language-rust z-code" data-lang=rust><code class=language-rust data-lang=rust><span class="z-source z-rust">    <span class="z-keyword z-operator z-range z-rust">...</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust">    <span class="z-keyword z-control z-rust">for</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">i</span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-variable z-local z-rust">chunk</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-rust">in</span> <span class="z-variable z-local z-rust">bitfield</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">chunks</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">enumerate</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">val</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-control z-rust">match</span> <span class="z-variable z-local z-rust">chunk</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">len</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span> <span class="z-keyword z-operator z-fatarrow z-rust">=></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">                <span class="z-storage z-type z-primitive z-rust">u64</span><span class="z-method z-rust"><span class="z-punctuation z-accessor z-rust">::</span><span class="z-variable z-function z-rust">from_be_bytes</span></span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">chunk</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">try_into</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">unwrap</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-variable z-local z-rust">x</span> <span class="z-keyword z-operator z-fatarrow z-rust">=></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">                <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> <span class="z-variable z-local z-rust">slice</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-constant z-numeric z-integer z-decimal z-rust">0</span><span class="z-storage z-type z-numeric z-rust">u8</span><span class="z-punctuation z-separator z-rust">;</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">                <span class="z-variable z-local z-rust">slice</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-keyword z-operator z-range z-rust">..</span><span class="z-variable z-local z-rust">x</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">copy_from_slice</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-keyword z-operator z-bitwise z-rust">&</span><span class="z-variable z-local z-rust">chunk</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-keyword z-operator z-range z-rust">..</span><span class="z-variable z-local z-rust">x</span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">                <span class="z-storage z-type z-primitive z-rust">u64</span><span class="z-method z-rust"><span class="z-punctuation z-accessor z-rust">::</span><span class="z-variable z-function z-rust">from_be_bytes</span></span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">slice</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">important_bits</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">idx</span> <span class="z-keyword z-operator z-arithmetic z-rust">%</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">64</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-keyword z-control z-rust">if</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">i</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">8</span> <span class="z-keyword z-operator z-comparison z-rust"><</span> <span class="z-variable z-local z-rust">len</span> <span class="z-keyword z-operator z-logical z-rust">||</span> <span class="z-variable z-local z-rust">important_bits</span> <span class="z-keyword z-operator z-comparison z-rust">==</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">0</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">a_count</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">val</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">count_zeros</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">usize</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-variable z-local z-rust">result</span> <span class="z-keyword z-operator z-assignment z-rust">+=</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">a_count</span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">A_SIZE</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-constant z-numeric z-integer z-decimal z-rust">64</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-variable z-local z-rust">a_count</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">B_SIZE</span><span class="z-punctuation z-section z-group z-end z-rust">)</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">            <span class="z-keyword z-control z-rust">continue</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-block z-rust">        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">shift_bits</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">64</span> <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-variable z-local z-rust">important_bits</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">b_count</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">val</span> <span class="z-keyword z-operator z-bitwise z-rust">>></span> <span class="z-variable z-local z-rust">shift_bits</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-bitwise z-rust"><<</span> <span class="z-variable z-local z-rust">shift_bits</span><span class="z-punctuation z-section z-group z-end z-rust">)</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">count_ones</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-rust">as</span> <span class="z-storage z-type z-primitive z-rust">usize</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">a_bytes</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">important_bits</span><span class="z-punctuation z-accessor z-dot z-rust">.</span><span class="z-variable z-function z-rust">saturating_sub</span><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-variable z-local z-rust">b_count</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">A_SIZE</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-storage z-type z-keyword z-rust">let</span> <span class="z-variable z-local z-rust">b_bytes</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-variable z-local z-rust">b_count</span> <span class="z-keyword z-operator z-arithmetic z-rust">*</span> <span class="z-keyword z-other z-self z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">B_SIZE</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">        <span class="z-variable z-local z-rust">result</span> <span class="z-keyword z-operator z-assignment z-rust">+=</span> <span class="z-variable z-local z-rust">a_bytes</span> <span class="z-keyword z-operator z-arithmetic z-rust">+</span> <span class="z-variable z-local z-rust">b_bytes</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust">    <span class="z-variable z-local z-rust">result</span>
</span><span class="z-source z-rust">}
</span></code></pre><p>I also tried <code>u32</code>-shitty-simd just in case, but that ended up being slower.<p>This could be improved by using run-length encoding, but that introduces some degenerate-case performance characteristics. If we store a reasonably-sized integer for the length, it'd use a ton more space when the type changes every single element. The worst possible case isn't a <em>huge</em> issue though, since at that point the end user should probably reach for <code>Vec<(A, B)></code> instead.<p>There are potential bit-packing solutions that could offer a more reasonable tradeoff. For example, bit 1 indicates the type, the next 3 bits indicate the run length, and 2 of those are packed into each <code>u8</code>. That's a potential project for another day though.<h3 id=traits>Traits<a aria-hidden=true class=anchor hidden href=#traits>#</a></h3><p>Those of you who muck around with pointers probably saw this coming. Notice that the <code>get</code> functions return <em>owned objects</em>, not references. This is the single biggest limitation of the container in my opinion.<p>Since the values are packed in memory, there's no guarantee that they are aligned properly. It is <strong>always</strong> UB to have a <code>&T</code> if <code>T</code> is unaligned. I'm hesitant to even have a function that hands out a raw pointers to <code>T</code> because it's so easy to do unaligned access wrong. I could use something like the <code>unaligned</code> crate and conditionally give out references when things happen to be aligned, but that comes with its own problems. Ideally I'd want the functions to be implemented on a trait, bounded by <code>align_of::&LTA>() == align_of::&LTB>()</code>, so the returned object is guaranteed to be aligned, but that requires <code>const_generic_expr</code> to be stabilized.<p>As a result, <code>A</code> and <code>B</code> are both required to be <code>Copy</code>. I left that detail out of the post until now mostly to make the signatures easier to read.<p>In the future, I may make an alternative "alignment-aware" version that ends up being a hybrid of <code>TwoVec</code> and <code>Vec::Enum</code>. It would only pad when necessary, so multiple small elements in a row could still be packed. Or, if ordering wasn't considered important, I could "backfill" the padding with new values.<p>Additionally, unlike <code>Vec</code> we cannot implement <code>Deref</code> or <code>AsRef</code> to anything else in any kind of sensible way because of how delicate and specialized the internal bookkeeping is. That severely limits the number of helper functions we can get "for free".<h3 id=space>Space<a aria-hidden=true class=anchor hidden href=#space>#</a></h3><p>While the storage overhead is typically much better than an enum, it's not guaranteed to be. The overhead varies based on how many elements are in the <code>TwoVec</code> and how large the size-difference is between types <code>A</code> and <code>B</code>. It has opposite storage characteristics to those of an enum - the overhead of an enum is worst when using mostly the small elements, whereas <code>TwoVec</code> stores the small variants much more efficiently, but can end up with a decent amount of wasted space when storing mostly large variants.<h2 id=but-why>But why?<a aria-hidden=true class=anchor hidden href=#but-why>#</a></h2><p>To be clear, I don't think this container is very practical. If you find a usecase for it, please do not tell me. Whatever problem you're solving is <em>unbelievably</em> cursed and I don't want it anywhere near me.<p>This is mostly inspired by some of the jank workarounds I used when completing Advent of Code in C since I didn't want to implement hashmaps from scratch, and I didn't feel super comfortable with unions. <code>TwoVec</code> is a living example of something that I learned from C:<p>Standard library types are a <em>generalist</em> solution that must be correct and useful in almost all cases. "Almost all" is not "every". There exists alternative ways of expressing your intent to the computer. In the same way that performance tuning is about informing the compiler about as many invariants as possible, sometimes it's okay to have a slightly gross data structure if it means it reflects your intentions better. In some cases, this also reduces the complexity of the final algorithm. Rules like "one type per array" or even "all array elements must be the same size" are just the tip of the iceberg. Calling them "rules" is itself sortof wrong. It's easy to forget that when reading discourse and advice about programming.<p>If I had to guess, I think that these sorts of "one-off, highly specific, slightly gross" data structures used to be more common back in the "wild west" days of programming. Back when hardware was much more limited, when languages and compilers were far less advanced, and when there was less "common knowledge" and "best practices" than we have today.<p>There are good reasons that they've fallen out of fashion - upkeep, readability, different performance priorities, etc. - but they shouldn't be considered non-options compared to generalized "standard-library"-esque data structures. Even if they're not necessary or practical, it still requires some lateral thinking and a deeper understanding of the language and underlying hardware. Those are always valuable skills to work on.</div><footer class=post-footer><ul class=post-tags><li><a href=https://walnut356.github.io/tags/programming/>programming</a><li><a href=https://walnut356.github.io/tags/rust/>rust</a></ul><nav class=paginav><a class=prev href=https://walnut356.github.io/posts/language-documentation/> <span class=title>« Prev</span> <br> <span>Why is language documentation still so terrible?</span> </a><a class=next href=https://walnut356.github.io/posts/so-you-want-better-debug-info/> <span class=title>Next »</span> <br> <span>So you want better debug info?</span> </a></nav></footer></article></main><footer class=footer><span>© 2025 <a href=https://walnut356.github.io>Walnut356</a></span><span> Powered by <a rel="noopener noreferrer" href=https://www.getzola.org/ target=_blank>Zola</a> & <a href=https://github.com/cydave/zola-theme-papermod rel=noopener target=_blank>PaperMod</a> </span></footer><a aria-label="go to top" title="Go to Top (Alt + G)" accesskey=g class=top-link href=#top id=top-link> <svg viewbox="0 0 12 6" fill=currentColor xmlns=http://www.w3.org/2000/svg><path d="M12 6H0l6-6z"/></svg> </a><script>let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });</script><script>var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };</script><script>document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })</script><script>document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';
        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                var content = codeblock.textContent;
                if(codeblock.firstChild.tagName == 'TABLE') {
                    content = Array(...codeblock.firstChild.getElementsByTagName('span')).map((span) => { return span.textContent; }).join('');
                }
                navigator.clipboard.writeText(content);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            // td containing LineNos
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            // table containing LineNos and code
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            // code blocks not having highlight as parent class
            codeblock.parentNode.appendChild(copybutton);
        }
    });</script>