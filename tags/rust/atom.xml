<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>A Walnut&#x27;s Thoughts - rust</title>
    <link href="https://Walnut356.github.io/tags/rust/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://Walnut356.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-03-09T00:00:00+00:00</updated>
    <id>https://Walnut356.github.io/tags/rust/atom.xml</id>
    <entry xml:lang="en">
        <title>The space-time-complexity tradeoff</title>
        <published>2024-03-09T00:00:00+00:00</published>
        <updated>2024-03-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://Walnut356.github.io/blog/space-time-complexity-tradeoff/" type="text/html"/>
        <id>https://Walnut356.github.io/blog/space-time-complexity-tradeoff/</id>
        
        <content type="html">&lt;p&gt;I encountered a neat example recently while solving &lt;a href=&quot;https:&#x2F;&#x2F;adventofcode.com&#x2F;2015&#x2F;day&#x2F;6&quot;&gt;Advent of Code 2015, day 6&lt;&#x2F;a&gt;. Code is compiled using &lt;code&gt;-Ctarget-cpu=native&lt;&#x2F;code&gt; for a Ryzen 1600x running Windows.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;&#x2F;h2&gt;
&lt;p&gt;To keep things simple, the problem can be boiled down to &amp;quot;There is a 2D array of values. Given a range and instruction, apply the instruction to all values in that range. How many values are &#x27;on&#x27; at the end?&amp;quot;. There are only 2 possible states for each value: on and off, and only 3 possible instructions: on, off, and toggle. I won&#x27;t focus too much on parsing the input or the structure of the algorithm here, I just want to investigate the hot loop which applies the instruction to each value.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;representation&quot;&gt;Representation&lt;&#x2F;h2&gt;
&lt;p&gt;Whenever I see a max of 2 states, my brain jumps straight to bit manipulation - why store in 8 bits what can be stored in 1 bit? The types of low-power, memory constrained platforms and programs I&#x27;ve investigated have given me lots of exposure bit fields. While that&#x27;s what I&#x27;m comfortable with, it&#x27;s often much closer to the &amp;quot;space&amp;quot; end of the space-time tradeoff. For something on the speedier side, we can represent the values as 8-bit bools.&lt;&#x2F;p&gt;
&lt;p&gt;While I could use an array of arrays, there&#x27;s no real need to when working with uniform dimensions (1000x1000 in this case). The bool array can be represented as &lt;code&gt;[bool; 1000 * 1000]&lt;&#x2F;code&gt; and the bit array as &lt;code&gt;[u8; 125 * 1000]&lt;&#x2F;code&gt;, saving 875kb. While that sounds like an insignificant amount, it&#x27;s worth noting that &lt;a href=&quot;https:&#x2F;&#x2F;www.techpowerup.com&#x2F;cpu-specs&#x2F;ryzen-5-1600x.c1894&quot;&gt;my CPU&lt;&#x2F;a&gt; has an L1 data cache size of 32kb and an L2 cache size of 512kb. The bitwise implementation could reside entirely in the L2 cache, whereas the bool array necessitates pulling some data from L3. L3 access can be &lt;a href=&quot;https:&#x2F;&#x2F;www.7-cpu.com&#x2F;cpu&#x2F;Zen.html&quot;&gt;somewhat expensive&lt;&#x2F;a&gt;, so it could make a difference.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;saving-time&quot;&gt;Saving time&lt;&#x2F;h2&gt;
&lt;p&gt;As a quick spoiler, the correct answer for my input data is &lt;code&gt;377891&lt;&#x2F;code&gt;. This blog post isn&#x27;t really about solving the problem (nor the most optimal solution), but it&#x27;s important to ensure that no matter what we change we&#x27;re still getting the correct answer. Wrong code is still wrong no matter how fast it is.&lt;&#x2F;p&gt;
&lt;p&gt;That aside, after parsing the line into the instruction and a Coordinate struct representing the &amp;quot;top left&amp;quot; and &amp;quot;bottom right&amp;quot; corners of the affected area, we can construct a simple loop that traverses the range&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; y in start.y..=end.y {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; x in start.x..=end.x {
&lt;&#x2F;span&gt;&lt;span&gt;        todo!()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For bools, the loop contents are very simple, just translate the 2D coordinate into a 1D array index. Also note that the nesting-order of the loop matters. Row-wise access is typically more performant due to locality. Simply reversing the order of the loop slows down execution time by about 30%.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; y in start.y..=end.y {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; x in start.x..=end.x {
&lt;&#x2F;span&gt;&lt;span&gt;        array[y * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;+ x] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; off:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; array[y * 1000 + x] = false;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; toggle:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; array[y * 1000 + x] ^= true;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To collect the values at the end, we can use an iter-fold:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;array.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;fold&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;acc&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;| acc + *x as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And hey, we get the correct answer in only ~18ms.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;saving-space&quot;&gt;Saving Space&lt;&#x2F;h2&gt;
&lt;p&gt;But what if we want to fiddle with bits? Well I&#x27;ve got 2 options in mind, and one is a bit spicy. The first is the simple bitwise operations we&#x27;re used to, the only tricky part being that we need to index into both the array and the individual u8s at the same time. 2D -&amp;gt; 1D array access is &lt;code&gt;y * width + x&lt;&#x2F;code&gt;. but since our array width is effectively 8x less, we need to divide both sides by 8. To get the offset into the u8, we need the remainder of &lt;code&gt;x &#x2F; 8&lt;&#x2F;code&gt;. We can then bitshift by that offset and set&#x2F;clear&#x2F;complement to apply the operation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; fun fact, the compiler isn&amp;#39;t smart enough to remove the
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; bounds check on the array access, even with the assertions:
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; assert!(start.y &amp;lt;= 999 &amp;amp;&amp;amp; end.y &amp;lt;= 999);
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; assert!(start.x &amp;lt;= 999 &amp;amp;&amp;amp; end.x &amp;lt;= 999);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; y in start.y..=end.y {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; x in start.x..=end.x {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; idx = (y * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;125&lt;&#x2F;span&gt;&lt;span&gt;) + (x &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; offset = x % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        bit_array[idx] |= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; offset;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; off:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; bit_array[idx] &amp;amp;= 0xFF ^ (1 &amp;lt;&amp;lt; offset);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; toggle:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; bit_array[idx] ^= 1 &amp;lt;&amp;lt; offset;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Collecting the values requires a slight modification of the iter-fold:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;bit_array
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;fold&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, |&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;acc&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;| acc + x.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;count_ones&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This runs a bit slower at ~28ms.&lt;&#x2F;p&gt;
&lt;p&gt;So how about a little spice? This was my original solution:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = bit_array.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;as_mut_ptr&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; y in start.y..=end.y {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; x in start.x..=end.x {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; bit_idx = y * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;+ x;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; wew
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            asm!(
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;bts [{ptr}], {bit_idx}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; off:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; &amp;quot;btr [{ptr}], {bit_idx}&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; toggle:
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; &amp;quot;btc [{ptr}], {bit_idx}&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                bit_idx = in(reg) bit_idx,
&lt;&#x2F;span&gt;&lt;span&gt;                ptr = in(reg) ptr,
&lt;&#x2F;span&gt;&lt;span&gt;            )
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I had just finished reading The Art of 64-bit Assembly, and the BT* instructions were fresh on my mind. For those that don&#x27;t read ISAs in your free time, BTS, BTR, and BTC are &lt;em&gt;very&lt;&#x2F;em&gt; cool instructions. The mnemonics are short for &amp;quot;Bit Test and &amp;lt;Set&#x2F;Reset&#x2F;Complement&amp;gt;&amp;quot;. You feed the instruction a memory address and a &lt;em&gt;bit&lt;&#x2F;em&gt; offset, and it sets it, clears it, or inverts it. It also sets the carry flag so you know what the bit was before you operated on it, and you can optionally make the instruction atomic.&lt;&#x2F;p&gt;
&lt;p&gt;It took me a few minutes to come up with - and convince myself of the correctness of - the indexing formula for the bitwise version. This version is the same level of cognitive complexity as the array of booleans, but with the space saving of the bitwise operations. Relative to other assembly instructions, I especially like how human-readable it is. I&#x27;ve spent a decent amount of time staring at PowerPC assembly, and the somewhat equivalent &lt;a href=&quot;https:&#x2F;&#x2F;www.ibm.com&#x2F;docs&#x2F;ru&#x2F;aix&#x2F;7.2?topic=is-rlwimi-rlimi-rotate-left-word-immediate-then-mask-insert-instruction&quot;&gt;RLWIMI&lt;&#x2F;a&gt; and RLWIMN instructions require &lt;a href=&quot;https:&#x2F;&#x2F;mariokartwii.com&#x2F;showthread.php?tid=1262&quot;&gt;several paragraphs&lt;&#x2F;a&gt; to explain, and are &lt;em&gt;still&lt;&#x2F;em&gt; kinda incomprehensible at a glance. RLWIMI has some cool differences, such as being able to operate on a range of bits all at once, but in most cases I see it used to modify a single bit.&lt;&#x2F;p&gt;
&lt;p&gt;All that aside, we can once again run it and see that we get the correct result, and a runtime of ... 47ms? Almost twice as slow as the bitwise version? That can&#x27;t be right. Lets pull the work out of the loops into their own functions and check the disassembly to see what&#x27;s actually going on. Running &lt;code&gt;cargo-show-asm&lt;&#x2F;code&gt; on the bitwise function reveals:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;aoc2015::day6::bit_on:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;            &#x2F;&#x2F; pub fn bit_on(bit_array: &amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;; 125 * 1000], x: usize, y: usize)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;sub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;40
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r9&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;            &#x2F;&#x2F; let idx = (y &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;125&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;(x &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;imul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;125
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;shr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;            &#x2F;&#x2F; bit_array&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;idx&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;|= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;&amp;lt;&amp;lt; offset&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;124999
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;ja &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;.LBB222_2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;dl&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;7
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r8b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;ecx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;edx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;shl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r8b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;cl
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;byte ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r9 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r8b
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;40
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;.LBB222_2:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;            &#x2F;&#x2F; bit_array&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;idx&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;|= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;&amp;lt;&amp;lt; offset&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;lea &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r8&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rip &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;__unnamed_373&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;edx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;125000
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;core::panicking::panic_bounds_check
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;ud2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And for the inline assembly function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;aoc2015::day6::asm_on:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;                &#x2F;&#x2F; pub fn asm_on(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;ptr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;mut u8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;x: usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;y: usize) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;                &#x2F;&#x2F; let bit_idx = y &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;imul &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;r8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;                &#x2F;&#x2F; asm!(
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        #APP
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;bts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        #NO_APP
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;pop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#61afef;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Ignoring the function setup&#x2F;teardown&#x2F;panic, the inline assembly is significantly shorter - just 3 instructions, no branches vs the 11 and never-taken branch of the bitwise function. So why&#x27;s it so much slower?&lt;&#x2F;p&gt;
&lt;p&gt;I mentioned in the bool function that the nesting order of the loops was important for cache locality. What I didn&#x27;t mention was that the equation changes when you&#x27;re operating repeatedly on a single value, which the ASM and bitwise functions both frequently do. Modern CPUs are pipelined, meaning they&#x27;re simultaneously executing several instructions at a time. A caveat of this is that any instruction that requires data from an instruction &lt;em&gt;currently in the pipeline&lt;&#x2F;em&gt; must wait until that instruction is completely finished before it can begin. This is called &lt;strong&gt;instruction latency&lt;&#x2F;strong&gt;. Stalling the pipeline like this can be disastrous for performance.&lt;&#x2F;p&gt;
&lt;p&gt;When we reverse the loop ordering, the bitwise function runs in ~26ms, essentially no change at all. On the other hand, the ASM function now executes in &lt;strong&gt;30ms&lt;&#x2F;strong&gt;, a massive speedup. This is likely due to the tighter overall loop - the previous value would have had time to clear the pipeline in the bitwise function due to the extra instructions and loop handling, but not in the ASM function. It&#x27;s not too surprising that both methods are slower than the boolean version though; we have to do a bit of extra work with the values involved, and the reduced cache locality likely has a slight negative impact.&lt;&#x2F;p&gt;
&lt;p&gt;There&#x27;s still a slight performance disparity between the two bitwise versions though and I&#x27;m honestly not 100% what it is. I investigated the &lt;a href=&quot;https:&#x2F;&#x2F;www.uops.info&#x2F;table.html&quot;&gt;instruction tables&lt;&#x2F;a&gt; for my CPU, the AMD64 Architecture Programmer&#x27;s Manual, and various forums. I&#x27;m not an expert at reading these sorts of sources by any means, but while the BT* instructions are definitely on the slower end, the numbers don&#x27;t seem unreasonably bad. The general consensus seems to be that they&#x27;re just slower than you&#x27;d expect when operating on memory.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;but-at-what-cost&quot;&gt;But at what cost?&lt;&#x2F;h2&gt;
&lt;p&gt;For the final version, we can throw readability in the garbage. Neither the bitwise nor the ASM version are really the most optimal way to operate on this sort of dataset. We&#x27;re operating on contiguous ranges, and because those ranges are usually pretty large, it makes more sense to do bulk operations rather than modify individual bits at a time. Doing so means we can maintain the cache locality of the bool version, the space savings of the bitwise version, and reduce the number of individual calls to memory greatly. To accomplish this, we can use u64&#x27;s as a sort of &amp;quot;poor man&#x27;s SIMD vector&amp;quot;. Due to bad divisibility, we&#x27;ll have to manage the fact that our &amp;quot;rows&amp;quot; won&#x27;t end on even boundaries - for example, our first row of 1000 bits will end on the 39th bit of u64 #15. Luckily, 1,000,000 &lt;em&gt;is&lt;&#x2F;em&gt; divisible by 64, so we don&#x27;t have to allocate any extra pad bytes. As an aside, an easier-to-reason-about method might be to have 16 rows of 1000, the extra space is simply ignored and doesn&#x27;t affect the final total.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll admit, this one took me several hours of debugging and a night&#x27;s sleep to get working properly. I ended up needing to write several of my own test cases, wrestle with the language, and correct a few of my own assumptions. Did you know that overflow on left shift (e.g. &lt;code&gt;u8::MAX &amp;lt;&amp;lt; 8&lt;&#x2F;code&gt;) is undefined behavior C and is disallowed in Rust? I didn&#x27;t, and apparently &lt;a href=&quot;https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;intentionally-overflow-on-shift&#x2F;11859&quot;&gt;I&#x27;m not the only one&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In any case, I want to walk through this as it&#x27;s a bit more involved than the previous examples.&lt;&#x2F;p&gt;
&lt;p&gt;Because we&#x27;re operating on a range, we&#x27;ll need start and end indexes. There isn&#x27;t clean divisibility, so we need to delay the division as long as possible to avoid compounding truncation errors. Another difference is that we need to take the modulo of the full bit-index, not just the x value like before. This is because the rows don&#x27;t always start and end on the same bit of their respective u64s (e.g. row 1 starts at bit 0, row 2 starts at bit 40).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; y in start.y..=end.y {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; start_idx = (y * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;+ start.x) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; start_offset = (y * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;+ start.x) % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; end_idx = (y * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;+ end.x) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; end_offset = (y * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;+ end.x) % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Next we set up the &lt;code&gt;start&lt;&#x2F;code&gt; bit mask by clearing the unnecessary bits via 2 bit shifts, and handle the case where the start and end index are identical. The second step isn&#x27;t necessary if you structure things a bit differently, but this makes a bit more sense to my brain. Note that when handling the &amp;quot;end&amp;quot; index, we need to alter the bit shifts so that we clear off bits on the opposite side.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; start = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;MAX&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    start &amp;lt;&amp;lt;= start_offset;
&lt;&#x2F;span&gt;&lt;span&gt;    start &amp;gt;&amp;gt;= start_offset;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; if we&amp;#39;re setting 64 bits or less, we modify only the start value
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; start_idx == end_idx {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; reverse of the above operation
&lt;&#x2F;span&gt;&lt;span&gt;        start &amp;gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;63 &lt;&#x2F;span&gt;&lt;span&gt;- end_offset;
&lt;&#x2F;span&gt;&lt;span&gt;        start &amp;lt;&amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;63 &lt;&#x2F;span&gt;&lt;span&gt;- end_offset;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        bit_array[start_idx] |= start;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    bit_array[start_idx] |= start;
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We then loop through the values between the start and end, replacing them with &lt;code&gt;u64::MAX&lt;&#x2F;code&gt;, 0, or &lt;code&gt;xor&lt;&#x2F;code&gt;ing them with &lt;code&gt;u64::MAX&lt;&#x2F;code&gt; as required.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; loop over x values
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in start_idx + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..end_idx {
&lt;&#x2F;span&gt;&lt;span&gt;        bit_array[i] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;MAX&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After that, we handle the end index and we&#x27;re all done!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; end = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;MAX&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; clear off only the bits within our range
&lt;&#x2F;span&gt;&lt;span&gt;    end &amp;gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;63 &lt;&#x2F;span&gt;&lt;span&gt;- end_offset;
&lt;&#x2F;span&gt;&lt;span&gt;    end &amp;lt;&amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;63 &lt;&#x2F;span&gt;&lt;span&gt;- end_offset;
&lt;&#x2F;span&gt;&lt;span&gt;    bit_array[end_idx] |= end;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Running this gives us the correct answer, in only 544.658Âµs - a speedup of ~30x over the boolean version using 1&#x2F;8th the memory, and a ~45x speedup over the bitwise version. All it cost was several hours, a bit of hair pulling, and some extra comments in the source code.&lt;&#x2F;p&gt;
&lt;p&gt;At this point, I suspect that we&#x27;re nearing the limit of how much faster we can make it. We could experiment with real SIMD registers and operate on even larger bit slices, but that&#x27;s for some other time. If you want to see the full source code, it&#x27;s available &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Walnut356&#x2F;AdventofCode&#x2F;blob&#x2F;master&#x2F;aoc2015&#x2F;src&#x2F;day6.rs&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I think this problem is a really neat demonstration of the tradeoffs between memory usage, CPU time, and the readability of your code. It also provides a nice reminder that sometimes readability can come from unlikely places - in this case, a simple assembly instruction has (arguably) less cognitive complexity than the equivalent high-level bitwise indexing. While we often see examples of what great code looks like, and how we can still make great code that&#x27;s &lt;em&gt;performant&lt;&#x2F;em&gt;, I always find it a fun exercise to &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4LiP39gJuqE&quot;&gt;throw all that to the wind and write some very fast, very gross code&lt;&#x2F;a&gt;. One of my favorite experiences with programming has been learning how insanely fast computers really are, and just how far you can push the limited tool sets that programming languages provide.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Can you estimate playtime from replay folder size?</title>
        <published>2024-01-25T00:00:00+00:00</published>
        <updated>2024-01-25T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://Walnut356.github.io/blog/estimate-playtime/" type="text/html"/>
        <id>https://Walnut356.github.io/blog/estimate-playtime/</id>
        
        <content type="html">&lt;p&gt;I&#x27;ve seen this question come up a few times on r&#x2F;ssbm and while I&#x27;ve given hand-wavey answers before, I find myself in a good place to answer more rigorously now. We can break this question down to more basic ones: &amp;quot;how many bytes of replay data correspond to a single frame of gameplay?&amp;quot; and &amp;quot;how many bytes in the replay are unrelated to frames?&amp;quot;. From there, we can estimate a duration by simply translating the 16.667ms per frame to minutes and seconds.&lt;&#x2F;p&gt;
&lt;p&gt;For the analysis, we&#x27;ll be using the replay parser I wrote in Rust. Replays &lt;em&gt;do&lt;&#x2F;em&gt; store their duration - both in their total frame count, and directly - so we&#x27;ll easily be able to check our work. We&#x27;ll be using my current netplay replays folder which contains my most recent ~1000 replays, several of which were filtered out for unimportant reasons.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;
Code
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; The DB here is still a WIP, so this is
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; the only SQL that will be in this post
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; conn = Connection::open_in_memory()?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stubs = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;parse_stubs&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;E:\Slippi Replays\Netplay\&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(stubs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; total = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u128&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; stub in stubs {
&lt;&#x2F;span&gt;&lt;span&gt;    total += stub.path.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;file_size&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u128&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(total);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;create_stubs&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;conn, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;parse_stubs&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;E:\Slippi Replays\Netplay\&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;))?;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;export&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;conn, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;test_db&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)?;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; stmt = conn.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;prepare&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;SELECT sum(duration) FROM stub;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;)?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; val = stmt.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;query&lt;&#x2F;span&gt;&lt;span&gt;([])?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;println!(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    val
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .get::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; just give me the number already &amp;gt;=(
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;
Output
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;cmd&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-cmd &quot;&gt;&lt;code class=&quot;language-cmd&quot; data-lang=&quot;cmd&quot;&gt;&lt;span&gt;    [slp_db\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;] stubs.len() = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1048&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;&#x2F; # of games
&lt;&#x2F;span&gt;&lt;span&gt;    [slp_db\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span&gt;] total = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;3682219473&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;&#x2F; byte count
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;155336180&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;&#x2F; total playtime in ms
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;After loading these into the database, a quick query gives us the total duration of all of the games: 155,336,180ms. Or, in a less disgusting unit, ~43 hours and 9 minutes. Accounting for the filtered replays, the total file size is 3,682,219,473 bytes or ~3.43GiB.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-exactly-is-in-a-replay-file&quot;&gt;What exactly is in a replay file?&lt;&#x2F;h2&gt;
&lt;p&gt;This is both an easy and a difficult question to answer. While we could directly inspect the assembly code that exports the replay data or the .slp file itself in a hex editor, there&#x27;s a much easier way: a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;project-slippi&#x2F;slippi-wiki&#x2F;blob&#x2F;master&#x2F;SPEC.md&quot;&gt;file specification&lt;&#x2F;a&gt; maintained by the slippi and slippi-adjacent devs. The spec helpfully lists the hexadecimal byte offsets of each field in each subsection. The values are not encoded or padded in any way, so simply adding the byte-length of the last field to the offset of the last field gives us the total size:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Event:&lt;&#x2F;th&gt;&lt;th&gt;Size:&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Payloads&lt;&#x2F;td&gt;&lt;td&gt;30&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Game Start&lt;&#x2F;td&gt;&lt;td&gt;761&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Pre-Frame&lt;&#x2F;td&gt;&lt;td&gt;65&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Post-Frame&lt;&#x2F;td&gt;&lt;td&gt;85&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Game End&lt;&#x2F;td&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Frame Start&lt;&#x2F;td&gt;&lt;td&gt;13&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Item Update&lt;&#x2F;td&gt;&lt;td&gt;45&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Frame Bookend&lt;&#x2F;td&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Gecko List&lt;&#x2F;td&gt;&lt;td&gt;uhh...&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The metadata event at the end doesn&#x27;t have a guaranteed size, but it&#x27;s roughly 250 bytes.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s also worth noting that these sizes are specifically for replays of version 3.16.0. As new versions come out and add new fields, events can be larger. It follows that events in older replays have smaller events. We can&#x27;t extract the replay version without parsing the replay, but the file creation date and&#x2F;or default file name (which contains the replay&#x27;s creation date) can be used as a proxy to that information. I manually compiled the release dates of the replay file versions by walking the git history of the replay recording asm file, a list is available &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Walnut356&#x2F;SlpProcess&#x2F;blob&#x2F;37c25c8488178157c0f97e1184385a62af82a6e1&#x2F;slp_parse&#x2F;src&#x2F;events&#x2F;game_start.rs#L508&quot;&gt;here&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So now we know what&#x27;s in a replay file, but that doesn&#x27;t tell us what&#x27;s &lt;em&gt;in&lt;&#x2F;em&gt; a replay file. For that, we need to bust out the hex editor:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;Walnut356.github.io&#x2F;blog&#x2F;estimate-playtime&#x2F;.&#x2F;header_bytes.png&quot; alt=&quot;hex editor&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;...&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;Walnut356.github.io&#x2F;blog&#x2F;estimate-playtime&#x2F;.&#x2F;gamestart_bytes.png&quot; alt=&quot;gamestart bytes&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;At the top we see the header, a 15 byte sequence that marks the beginning of a .slp file, which we can add on to our non-frame data total. Next we can see the command byte for the Event Payloads (&lt;code&gt;0x35&lt;&#x2F;code&gt;), followed by the command byte for the Game Start event (&lt;code&gt;0x36&lt;&#x2F;code&gt;). The next thing we see though isn&#x27;t the start of the first frame of data as might be expected, it&#x27;s event code &lt;code&gt;0x10&lt;&#x2F;code&gt; which corresponds to the Message Splitter. The layout and implementation are a bit confusing, so I&#x27;ll gloss over the specifics. Long story short this contains all of the gecko codes used when the replay was recorded. As I understand it, this exists to prevent playback desyncs, especially in spectator mode. Unfortunately for us it means we&#x27;re going to have to formalize the fact that our playtime estimate will be an &lt;em&gt;estimate&lt;&#x2F;em&gt;, not an exact match.&lt;&#x2F;p&gt;
&lt;p&gt;See, when you play a match against someone online, each of your dolphin instances generates a replay file. As many of you probably know, there are a handful of &amp;quot;netplay safe&amp;quot; gecko codes out there - codes that can be added by an individual, but won&#x27;t desync if their opponent doesn&#x27;t have it. These can change from game to game as the player toggles them on or off. Also, there is no &amp;quot;sharing&amp;quot; of gecko codes, and no &amp;quot;canonical&amp;quot; list of gecko codes for that game, thus each dolphin instance records the gecko codes that it had enabled at the time. That means 2 (or more via broadcasting) replay files of the same game are &lt;em&gt;not&lt;&#x2F;em&gt; guaranteed to be identical. Keep that in mind, as it will come up again later.&lt;&#x2F;p&gt;
&lt;p&gt;This means that, at best, we can only guess at how large people&#x27;s gecko codes will be. There are some limits to how small and large the gecko codes section can be, but for now, we&#x27;ll just assume everyone uses the same ones I do: the required and recommended set, as well as Flash Red on Failed L-Cancel.&lt;&#x2F;p&gt;
&lt;p&gt;My parser stores offsets of each event as an intermediate step, so we can pull the offset of the first pre-frame event, subtract out the non-gecko event sizes, and we get a gecko code size of 56,124 bytes. The game-end and metadata events also occur once per game (assuming no bugs). That means that, for this replay, ~56,374 bytes do not contribute to the duration.&lt;&#x2F;p&gt;
&lt;p&gt;We can multiply this by the total number of replays and subtract it out from the total byte count of the files, leaving us with ~3,623,139,521 bytes of pure frame data&lt;&#x2F;p&gt;
&lt;h2 id=&quot;frame-data&quot;&gt;Frame data&lt;&#x2F;h2&gt;
&lt;p&gt;The naive solution is to just divide the remaining bytes by the size of frame start + pre frame + post frame + frame end (172 bytes). That gets us 21,064,764 frames, which we can multiply by 16.667 to get 351,086,432ms, or ~97.5 hours, which slightly more than double the actual time.&lt;&#x2F;p&gt;
&lt;p&gt;One issue stands out immediately: frame start and frame end events only happen once per frame, whereas pre- and post-frame events happen once &lt;em&gt;per character&lt;&#x2F;em&gt; per frame. Note how there are 2 pre-frames (&lt;code&gt;0x37&lt;&#x2F;code&gt;) and 2 post-frames (&lt;code&gt;0x38&lt;&#x2F;code&gt;) in this single span from one frame start (&lt;code&gt;0x3A&lt;&#x2F;code&gt;) to another:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;Walnut356.github.io&#x2F;blog&#x2F;estimate-playtime&#x2F;one_frame.png&quot; alt=&quot;frame span&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Because these are generated per character, there will sometimes be more than 2 pre&#x2F;post frame events per frame start&#x2F;end. Nana generates her own frame events when she&#x27;s alive, and doubles games will generate events for everyone who is alive. In my case, I don&#x27;t have any doubles replays and I don&#x27;t think there&#x27;s a statistically significant enough number of ice climbers games in my replay set for it to matter. That means each 16.667ms, it should be exactly (13 + 9 + (65 * 2) + (85 * 2)) = 322 bytes. That would mean we have ~11,251,986 frames, which is 187,536,852ms, or ~52 hours. It&#x27;s fairly close to our goal of 43 hours, but still about 20% too high.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;item-frames&quot;&gt;Item Frames&lt;&#x2F;h2&gt;
&lt;p&gt;Items are a bit of a can of worms. &amp;quot;Item&amp;quot; in this context is more a game engine term than a colloquial one. We&#x27;d normally think of items as being projectiles - falco&#x27;s laser, turnips, pills. In engine terms though, an item is basically any non-player, non-stage, non-ui entity. Using the items tab of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Walnut356&#x2F;stats-dash&quot;&gt;stats dash&lt;&#x2F;a&gt;, we can see what (and how many) items falco spawned in a single game:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;Walnut356.github.io&#x2F;blog&#x2F;estimate-playtime&#x2F;falco_items.png&quot; alt=&quot;falco items&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Huh. Not just are lasers items, but also falco&#x27;s gun itself as well as the trail left behind by his side B. Some characters have lots of items - most of GnW&#x27;s attacks involve an item - some characters have basically none. There&#x27;s also some extra weirdness with things like samus&#x27;s charge shot, which count as items during the charging animation, even though they&#x27;re not &amp;quot;active&amp;quot; and able to deal damage. Things like marth&#x27;s sword that are permanently attached to his player model don&#x27;t count, but then shine doesn&#x27;t count when it seems like maybe it should. I&#x27;ve been surprised more than a few times by what does and doesn&#x27;t count as an item.&lt;&#x2F;p&gt;
&lt;p&gt;Either way, that means that there isn&#x27;t a perfect &amp;quot;generalized&amp;quot; method to predict how many item frames are present in a game. Knowing what characters are in it &lt;em&gt;helps&lt;&#x2F;em&gt;, but we&#x27;ve restricted ourselves to file size as our only source of info so at best we could only guess by an additional proxy guess of the average character distribution (which also assumes that you have roughly the same set length vs, say, game and watch that you do vs fox which likely isn&#x27;t true). It&#x27;s still probably worth checking if item frames occupy a significant fraction of my game time though which is pretty simple:&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;
Code
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; replay = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;E:\Slippi Replays\Netplay\&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; games = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;parse&lt;&#x2F;span&gt;&lt;span&gt;(replay, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(
&lt;&#x2F;span&gt;&lt;span&gt;    games
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;g&lt;&#x2F;span&gt;&lt;span&gt;|
&lt;&#x2F;span&gt;&lt;span&gt;            g.item_frames.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;as_ref&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        )
&lt;&#x2F;span&gt;&lt;span&gt;        .sum::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;
Output
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;cmd&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-cmd &quot;&gt;&lt;code class=&quot;language-cmd&quot; data-lang=&quot;cmd&quot;&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;91&lt;&#x2F;span&gt;&lt;span&gt;] games.iter().map(|g| g.item_frames.as_ref().unwrap().len()).sum::&amp;lt;usize&amp;gt;() = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;5229553
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;5,229,553 * 45 = 235,329,885 bytes. Removing that from our total gives us 3,387,809,636 bytes, which is 10,521,148 frames, 175,355,973ms, or ~48.71 hours. At least for someone who plays falco 90% of the time. Our estimate is still about 13% too high though.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;too-many-frames&quot;&gt;Too many frames&lt;&#x2F;h2&gt;
&lt;p&gt;13% too high is kind of a lot. The remaining data is purely frame data, and it&#x27;s not being thrown off by items or characters generating extra frames. So why do we have so much extra data?&lt;&#x2F;p&gt;
&lt;p&gt;When I built the parser, I compared the output to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hohav&#x2F;py-slippi&quot;&gt;py-slippi parser&lt;&#x2F;a&gt; which I had previously verified as accurate, and I found that the outputs didn&#x27;t match. The data from the first bit of the replay seemed fine, but later in the replay some things appeared to be happening &amp;quot;too early&amp;quot;. The data looked &amp;quot;valid&amp;quot;, it was just in the wrong location in the parsed data. I agonized a bit over how I was handling offsets, but the end-game data was correct as well. After some time stepping through my parser with a debugger and comparing the output to dolphin playing back the replay, I wrote a quick test that should have occurred to me from the start - do these parsers end up with the same total number of frames?&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;
Code
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;slippi &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;# py-slippi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;slp_parse &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;# rust parser via python wrapper
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;replay = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;test_replays&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;etplay_sample&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;slp&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;# frame count from py-slippi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;print&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(slippi.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;Game&lt;&#x2F;span&gt;&lt;span&gt;(replay).frames))
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;# frame count from my parser
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;print&lt;&#x2F;span&gt;&lt;span&gt;(slp_parse.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;parse&lt;&#x2F;span&gt;&lt;span&gt;(replay, true)[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;].players[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;].frames.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;
Output
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;cmd&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-cmd &quot;&gt;&lt;code class=&quot;language-cmd&quot; data-lang=&quot;cmd&quot;&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;9808&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;&#x2F; py-slippi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;9822&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;&#x2F; slp_parse
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;Ah. Shit.&lt;&#x2F;p&gt;
&lt;p&gt;As many of you probably know, rollback netplay works by guessing your opponent&#x27;s inputs when they arrive too late, then re-simulating the previous few frames once the accurate inputs finally arrive. What you may not know is that the code that generates the replay is written in assembly and is called directly by the engine&#x27;s main loop. That means when the game re-simulates, it calls the recording code again and records those re-simulated frames. This is a good thing, it means that the &amp;quot;canonical&amp;quot; game exists within the replay file. The bad news is that there&#x27;s no handling for &amp;quot;cleaning up&amp;quot; those rollback&#x27;d frames (and it&#x27;s generally good that they&#x27;re left in for debugging purposes) and my parser was treating them just like any other frame. Py-slippi has special handling for &amp;quot;finalized&amp;quot; frames - and the slippi file spec even mentions it in the frame end event.  For compatibility reasons, I don&#x27;t rely on the frame end event, and I didn&#x27;t have any special handling. As a result, my parser&#x27;s frames were drifting apart from &amp;quot;reality&amp;quot; because rollback&#x27;d frames were sneaking in. Solving that was fairly easy, but what does this mean for estimating playtime?&lt;&#x2F;p&gt;
&lt;p&gt;All replay files will have extra &amp;quot;garbage&amp;quot; data that doesn&#x27;t count towards playtime. How much &amp;quot;garbage&amp;quot; data? Depends on how bad your connection was as well as how often the engine mis-predicted inputs. It&#x27;s worth noting that because the engine is re-simulating full frames, all the above issues (Nana, items, doubles) apply to each rollback&#x27;d frame. Remember when I said that 2 replay files of the same aren&#x27;t guaranteed to be identical? That&#x27;s true for this too. The rollback&#x27;d frames in each replay will very likely be different between the two replays because your opponent&#x27;s client has to re-simulate via your inputs and you have to re-simulate via theirs; one client may guess wrong at the same time that the other guesses right.&lt;&#x2F;p&gt;
&lt;p&gt;All hope isn&#x27;t lost though. Matchmaking typically makes sure pings aren&#x27;t too ridiculous between players. Even when it can&#x27;t, most players won&#x27;t play those games out. That means, in general, the number of rollback frames should be pretty low. Finding out how many is pretty simple, just compare the total number of frames in the replay to the amount of &amp;quot;valid&amp;quot; frames:&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;
Code
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; replay = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#98c379;&quot;&gt;&amp;quot;E:\Slippi Replays\Netplay\&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; games = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;parse&lt;&#x2F;span&gt;&lt;span&gt;(replay, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; a replay *probably* can&amp;#39;t be 100% rollback frames
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; but may as well be safe
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; counts = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; max: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0.0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; min: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;100.0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; total_frames = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; total_rbs = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; game in games {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; tf = game.total_frames;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; rbs = game.frames_rollbacked;
&lt;&#x2F;span&gt;&lt;span&gt;    total_frames += tf;
&lt;&#x2F;span&gt;&lt;span&gt;    total_rbs = rbs;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; rbs == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        counts[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p = rbs as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32 &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; (rbs + tf) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; group by 10%, shifted 1 idx forward
&lt;&#x2F;span&gt;&lt;span&gt;    counts[(p * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;10.0 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1.0&lt;&#x2F;span&gt;&lt;span&gt;) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;] += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    max = max.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span&gt;(p);
&lt;&#x2F;span&gt;&lt;span&gt;    min = min.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span&gt;(p);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; maximum rollback percentage
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(max);
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; minimum non-0 rollback percentage
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(min);
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; number of games with X% rollbacks
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; where idx 0 = 0%, idx 1 = 0..10% non-inclusive...
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(counts);
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(total_rbs);
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(total_frames);
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; percentage of rollback frames over all games
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(total_rbs as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32&lt;&#x2F;span&gt;&lt;span&gt;&#x2F; (total_rbs as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32 &lt;&#x2F;span&gt;&lt;span&gt;+ total_frames as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;
Output
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;cmd&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-cmd &quot;&gt;&lt;code class=&quot;language-cmd&quot; data-lang=&quot;cmd&quot;&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;113&lt;&#x2F;span&gt;&lt;span&gt;] max = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;51921797
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;114&lt;&#x2F;span&gt;&lt;span&gt;] min = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;.818957e-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;5
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;115&lt;&#x2F;span&gt;&lt;span&gt;] counts = [
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;148&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;575&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;120&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;89&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;102&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;116&lt;&#x2F;span&gt;&lt;span&gt;] total_rbs = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;1073691
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;117&lt;&#x2F;span&gt;&lt;span&gt;] total_frames = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;9450144
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;118&lt;&#x2F;span&gt;&lt;span&gt;] total_rbs as f32 &#x2F; (total_rbs as f32 + total_frames as f32) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;10202469
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Percent&lt;&#x2F;th&gt;&lt;th&gt;Count&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;148&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0.01-9.99&lt;&#x2F;td&gt;&lt;td&gt;575&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;10.00-19.99&lt;&#x2F;td&gt;&lt;td&gt;120&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;20.00-29.99&lt;&#x2F;td&gt;&lt;td&gt;89&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;30.00-39.99&lt;&#x2F;td&gt;&lt;td&gt;102&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;40.00-49.99&lt;&#x2F;td&gt;&lt;td&gt;12&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&amp;gt;50&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The vast majority of replays were less than 10% rollback&#x27;d data, and the total number of rollback&#x27;d frames is ~10.2%. If we remove this data from our total we are left with 3,042,081,134 bytes. Converting this to time as above leaves us with 9,447,457 frames and a playtime of 157,460,765ms or ~43.74 hours. That&#x27;s a difference of only 35 minutes compared to our expected time! We got there by cheating a little, but we&#x27;ve established some important invariants and some decent guesses for things that aren&#x27;t guaranteed. In this instance, items + rollbacks accounted for ~20% of replay data, and the rest can be accounted for via file spec guarantees. 20% isn&#x27;t a bad number to start guessing with&lt;&#x2F;p&gt;
&lt;p&gt;There are a few other things that could affect the replay size, but involve incredibly rare bugs that cause events to be duplicated or missing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-test&quot;&gt;The test&lt;&#x2F;h2&gt;
&lt;p&gt;I have ~63GiB of replays dating back to 2020, so for this test I&#x27;ll combine everything we&#x27;ve learned above into a simple formula and apply it to my replay data from 2022. One thing worth mentioning is the slippi versions at that time. 2022 had 4 major versions, but 3 of them were released in January&#x2F;February. Most of the year was played on 3.12.0, with a solid few months on both 3.13.0 and 3.14.0. Thankfully, the size of the pre-, post-, and item-frame events are all the same on all of those versions. There&#x27;s a few minor differences in some of the &amp;quot;once per file&amp;quot; fields, but since metadata and gecko codes are already estimates, it shouldn&#x27;t matter too much. If I was building this more robustly, I&#x27;d have it dynamically alter the byte counts based on file dates, but that&#x27;s not necessary for this test.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;
Code
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; games = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;parse&lt;&#x2F;span&gt;&lt;span&gt;(replay, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; actual_dur: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u128 &lt;&#x2F;span&gt;&lt;span&gt;= games
&lt;&#x2F;span&gt;&lt;span&gt;                        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;g&lt;&#x2F;span&gt;&lt;span&gt;| g.duration.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;as_millis&lt;&#x2F;span&gt;&lt;span&gt;()).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;sum&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; size = games
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e06c75;&quot;&gt;g&lt;&#x2F;span&gt;&lt;span&gt;|
&lt;&#x2F;span&gt;&lt;span&gt;            File::open(g.path.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;to_str&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;file_size&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        )
&lt;&#x2F;span&gt;&lt;span&gt;        .sum::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(size);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; guess_frames =
&lt;&#x2F;span&gt;&lt;span&gt;    ((size - (games.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u64 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;56_300&lt;&#x2F;span&gt;&lt;span&gt;)) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;f32 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0.8&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;314.0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#5c6370;&quot;&gt;&#x2F;&#x2F; post-frame is 4 bytes smaller than 3.16.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(guess_frames);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; guess_ms = guess_frames * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;16.667&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(guess_ms);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;dbg!(actual_dur.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#56b6c2;&quot;&gt;abs_diff&lt;&#x2F;span&gt;&lt;span&gt;(guess_ms as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c678dd;&quot;&gt;u128&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;
Output
&lt;&#x2F;summary&gt;
&lt;pre data-lang=&quot;cmd&quot; style=&quot;background-color:#282c34;color:#abb2bf;&quot; class=&quot;language-cmd &quot;&gt;&lt;code class=&quot;language-cmd&quot; data-lang=&quot;cmd&quot;&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;97&lt;&#x2F;span&gt;&lt;span&gt;] size = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;16837148506
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;] guess_frames = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;42221164&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;103&lt;&#x2F;span&gt;&lt;span&gt;] guess_ms = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;703700160&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;104&lt;&#x2F;span&gt;&lt;span&gt;] actual_dur = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;703206555
&lt;&#x2F;span&gt;&lt;span&gt;[slp_parse\src\main.rs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;106&lt;&#x2F;span&gt;&lt;span&gt;] actual_dur.abs_diff(guess_ms as u128) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d19a66;&quot;&gt;493605
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;details&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;Playtime (ms)&lt;&#x2F;th&gt;&lt;th&gt;Playtime (hours)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Guess&lt;&#x2F;td&gt;&lt;td&gt;703700160&lt;&#x2F;td&gt;&lt;td&gt;195.5&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Actual&lt;&#x2F;td&gt;&lt;td&gt;703206555&lt;&#x2F;td&gt;&lt;td&gt;195.3&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Diff&lt;&#x2F;td&gt;&lt;td&gt;493605&lt;&#x2F;td&gt;&lt;td&gt;.14&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Well well well, that&#x27;s a difference of only &lt;em&gt;8 minutes&lt;&#x2F;em&gt;, a difference of ~0.07%. Using only the file size, the number of files, and a little bit of investigation into a file format. I&#x27;d say that&#x27;s a success. There&#x27;s a few asterisks, but they can mainly be boiled down to the &lt;code&gt;0.8&lt;&#x2F;code&gt; scalar in the formula. If you play a different character or have better&#x2F;worse connections on average, that number might need to be fiddled with.&lt;&#x2F;p&gt;
&lt;p&gt;Is it practical? Uh... kinda. Opening a bunch of file handles and doing a handful of math operations is WAY faster than parsing all of the replays - especially if you aren&#x27;t using a compiled parser (which are still bottlenecked by disk read speed, even when only partially parsing files). I think most slippi-adjacent apps are already parsing replays for other purposes though, so there&#x27;s not really anything gained over just pulling it straight from the parsed file.&lt;&#x2F;p&gt;
&lt;p&gt;Still, neat.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
